## http基础

## header

### general 通用头部 (同时适用于请求和响应消息，但与最终消息传输的数据无关的消息头 不属于headers，只用于收集请求url和响应的status等信息)

- Request URL: http://nivelle.me:39300/nd_admin/settlement/list?page=1&size=10&total=0&count=0&companyId=&companyName=

- Request Method: GET

- Status Code: 200

- Remote Address: 39.107.11.210:443 //路由地址

- Referrer Policy: no-referrer-when-downgrade

- Date:创建报文的日期时间

- Keep-Alive:用来设置超时时长和最大请求数

- Cache-Control: //缓存控制

    1. no-store 规定不能对请求或响应的任何一部分进行缓存(no-store 规定不能对请求或响应的任何一部分进行缓存)

    2. no-cache (no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。)

    3. max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存; max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。或者使用Expires

- If-None-Match: //缓存验证

  可以将缓存资源的值放入request header的 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 值和资源的最新 值是否一致，如果一致则表示缓存资源有效，返回 304 Not
  Modified。并在response header中戴上 ETag 值

```
//请求
If-None-Match: W/"646-RJRVaOjMluW+SOAL0EThThA2lnM"

//响应
ETag: W/"646-RJRVaOjMluW+SOAL0EThThA2lnM"
```

### Request Headers(包含更多有关要获取的资源或客户端本身信息的消息头)

- Accept:告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型;

- Accept-Charset:浏览器申明自己接收的字符集

- Accept-Encoding: 浏览器申明自己接收的编码方法,通常指定压缩方法,是否支持压缩,支持什么压缩方法(gzip,deflate)

- **Connection:表示是否需要持久连接。** close（告诉WEB服务器或者代理服务器,在完成本次请求的响应后，断开连接,不要等待本次连接的后续请求了）。keep-alive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。

- Authorization: HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

- Content-Type: 请求参数对应的MIME信息

- Referer: 先前网页的地址，当前请求网页紧随其后,即来路

- Origin: 表明了请求来自于哪个站点  (eg:<scheme> "://" <host> [ ":" <port> ])

### Response Headers(包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头)

- Content-Location: 请求资源可替代的备用的另一地址

- Location: 令客户端重定向至指定 URI;

- Allow: 对某网络资源的有效的请求行为,不允许则返回405

- Content-Type:返回内容的MIME类型    (Content-Type: text/html; charset=utf-8)

### Entity Headers(包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型)

- Expires:包含日期/时间,即在此时候之后,响应过期(如果在Cache-Control响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 Expires 头会被忽略)

- Last-Modified: 资源的最后修改日期时间

- Content-Length: 发送给接收方的消息主体的大小；

- Content-Type:告诉客户端实际返回的内容的内容类型；详情

## mime

![常见mime类型](https://s1.ax1x.com/2020/07/03/NviMWj.png)

### 状态码

- 100(continue) 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

- 200(OK) 表示从客户端发来的请求在服务器端被正常处理了。

- 204(No Content) 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。

- **206(Partial Content) 该状态码表示客户端进行了范围请求**，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。
----
- **301(Moved Permanently) 永久性重定向**。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。

- **302(Found) 临时性重定向**。比如在没有登录情况下访问网站"个人中心"，会重定向到登录页，但是你登录后，访问个人中心时，它又不会重定向到其他地方了。

- 303(See Other) 和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

- **304(Not Modified) 如果请求报文首部包含一些条件**，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
  - 表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。
----
- 400(Bad Request) 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。

- **401 Unauthorized 该状态码表示发送的请求需要有认证信息**。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以询问用户信息。当浏览器初次接收到 401
  响应，会弹出认证用的对话窗口。第二次接收到，则不弹出，直接表示认证失败。

- **403(Forbidden) 对请求资源的访问被服务器拒绝了**，一般是未获得文件系统的访问授权，问权限出现某些问题。

- 404(Not Found) 浏览器地址错误。服务器找不到对应资源。

- 429(Too Many Requests) 如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务

- 431(Request Header Fields Too Large) 请求头字段太大
-----
- **500(Internal Server Error) 服务器在执行时报错。**

- **502(bad gateWay)**:通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问服务器发送了错误。

- **503(Service Unavailable) 服务器暂时处于超负载或正在进行停机维护，无响应。一般需要重启服务器即可。**

### CORS

是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。

当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。

#### 1. 简单请求

需要满足下列所有条件：

- 第一条: 请求方式必须为 GET | HEAD

- 第二条: Content-Type 的值必须属于下列之一 (application/x-www-form-urlencoded | multipart/form-data | text/plain)

例如: 在http://foo.exmaple上要访问 http://bar.other上的资源。则
```text
//request headers上添加
Origin: http://foo.example


//response headers返回
Access-Control-Allow-Origin: *

```

如果返回

```
Access-Control-Allow-Origin: http://foo.example
```

#### 2. 非“简单请求”（触发CORS预检请求）


需要满足下列所有条件：

- 第一条： http请求方式为下列
POST | PUT | DELETE | CONNECT | OPTIONS | TRACE | PATCH

- 第二条： Content-Type 的值不属于下列之一:
application/x-www-form-urlencoded | multipart/form-data | text/plain


如果在 http://foo.exmaple 上要访问 http://bar.other/resources/po... 上的资源。且 request headers 中
Content-Type为application/xml，请求method为post。 那么此请求是个“非简单请求”。首先浏览器会自动发送带有options选项的预检请求，然后发送实际请求:

```
//预检请求request headers
OPTIONS /resources/post-here/ HTTP/1.1（自动，不需要设置）

//设置预检请求的response headers
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
```
---
## HTTP 与 HTTPS 

### Q1: 什么是 HTTPS？

- HTTPS 是安全的 HTTP
- HTTP 协议中的内容都是明文传输，HTTPS 的目的是将这些内容加密，确保信息传输安全。最后一个字母 S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。

### Q2: 你说的信息传输安全是什么意思(加密+防篡改)

- 客户端和服务器直接的通信只有自己能看懂，即使第三方拿到数据也看不懂这些信息的真实含义。
- 第三方虽然看不懂数据，但可以 XJB 改，因此客户端和服务器必须有能力判断数据是否被修改过。
- 客户端必须避免中间人攻击，即除了真正的服务器，任何第三方都无法冒充服务器。
很遗憾的是，目前的 HTTP 协议还不满足上述三条要求中的任何一条。

### Q3: 这么多要求，一个一个去满足是不是很累？
- 第三个要求可以不用管
我们都知道加密需要密码，密码不是天下掉下来，也得需要双方经过通信才能协商出来。所以一个设计良好的加密机制必然会防止第三者的干扰和伪造。等搞明白了加密的具体原理，我们自然可以检验是否满足:“任何第三者无法冒充服务器”这一要求。

### Q4: 那怎么加密信息呢

- 使用对称加密技术
- 对称加密可以理解为对原始数据的可逆变换。比如 Hello 可以变换成 Ifmmp，规则就是每个字母变成它在字母表上的后一个字母，这里的秘钥就是 1，另一方拿到 Ifmmp 就可以还原成原来的信息 Hello 了。

引入对称加密后，HTTPS 的握手流程就会多了两步，用来传递对称加密的秘钥:

````text
客户端: 你好，我需要发起一个 HTTPS 请求
服务器: 好的，你的秘钥是 1。

````
提到了对称加密，那么自然还有非对称加密。它的思想很简单，计算两个质数的乘积很容易，但反过来分解成两个质数的乘积就很难，要经过极为复杂的运算。非对称加密有两个秘钥，一个是公钥，一个是私钥。公钥加密的内容只有私钥可以解密，私钥加密的内容只有公钥可以解密。一般我们把服务器自己留着，不对外公布的密钥称为私钥，所有人都可以获取的称为公钥。

使用对称加密一般要比非对称加密快得多，对服务器的运算压力也小得多。

### Q5: 对称秘钥如何传输

- 服务器直接返回明文的**对称加密密钥**是不是不安全。如果有监听者拿到这个密钥，不就知道客户端和服务器后续的通信内容了么？

- **利用非对称加密** 是这样，所以不能明文传递对称秘钥，而且也不能用一个新的对称加密算法来加密原来的对称秘钥，否则新的对称秘钥同样无法传输，这就是鸡生蛋、蛋生鸡的悖论。

- 这里我们引入**非对称加密的方式**，非对称加密的特性决定了服务器用私钥加密的内容并不是真正的加密，因为公钥所有人都有，所以服务器的密文能被所有人解析。但私钥只掌握在服务器手上，这就带来了两个巨大的优势:

  - **服务器下发的内容不可能被伪造:** 因为别人都没有私钥，所以无法加密。强行加密的后果是客户端用公钥无法解开。
  - **任何人用公钥加密的内容都是绝对安全的:** 因为私钥只有服务器有，也就是只有真正的服务器可以看到被加密的原文。

所以传输对称秘钥的问题就迎刃而解了: 秘钥不是由服务器下发，而是由客户端生成并且主动告诉服务器。

所以当引入非对称加密后，HTTPS 的握手流程依然是两步，不过细节略有变化:

````text
客户端: 你好，我需要发起一个 HTTPS 请求，这是我的 (用公钥加密后的) 秘钥。
服务器: 好的，我知道你的秘钥了，后续就用它传输。

````
### Q5: 那公钥怎么传输

- 你好像还是没有解决鸡生蛋，蛋生鸡的问题。你说客户端发送请求时要用公钥加密对称秘钥，那公钥怎么传输呢？

#### BS: 对公钥加密就行了。。。

- 每一个使用 HTTPS 的服务器都必须去专门的证书机构注册一个证书，证书中存储了用权威机构私钥加密的公钥。这样客户端用权威机构的公钥解密就可以了。

##### 现在 HTTPS 协议的握手阶段变成了四步:

````text
客户端: 你好，我要发起一个 HTTPS 请求，请给我公钥
服务器: 好的，这是我的证书，里面有加密后的公钥
客户端: 解密成功以后告诉服务器: 这是我的 (用公钥加密后的) 对称秘钥。
服务器: 好的，我知道你的秘钥了，后续就用它传输。

````
### Q6: 你在逗我么。。。。

- 那权威机构的公钥又怎么传输？

#### BS: 存在电脑里

- 这个公钥不用传输，会直接内置在各大操作系统(或者浏览器)的出厂设置里。之所以不把每个服务器的公钥内置在电脑里，一方面是因为服务器太多，存不过来。另一方面操作系统也不信任你，凭什么你说你这个就是百度/淘宝的证书呢？

- 所以各个公司要先去权威机构认证，申请证书，然后操作系统只会存储权威机构的公钥。因为权威机构数量有限，所以操作系统厂商相对来说容易管理。如果这个权威机构不够权威，XJB 发证书，就会取消他的资格，比如可怜的沃通。。。。

### Q7: 怎么知道证书有没有被篡改？

- 你说服务器第一次会返回证书，也就是加密以后的公钥，那我怎么知道这个证书是可靠的？

#### BS: 将信息 hash 值随着信息一起传递

- 我们都知道哈希算法的特点，它可以压缩数据，如果从函数角度来看，不管多复杂的数据(定义域可以非常大)经过哈希算法都会得到一个值，而且这个值处在某个特定(远小于定义域的范围)值域内。相同数据的哈希结果一定相同，不相同数据的哈希结果一般不同，不过也有小概率会重复，这叫哈希冲突。

- 为了确保原始证书没有被篡改，我们可以在传递证书的同时传递证书的哈希值。由于第三者无法解析数据，只能 XJB 改，那么修改后的数据在解密后，就不可能通过哈希。

比如说公钥就是之前的例子 Hello，我们假设哈希算法是获取字符串的最后一个字符，那么 Hello 的哈希值就是 o，所以加密字符串是 Ifmmpp。虽然公钥已知，每个人都可以解密，解密完也可以篡改，但是因为没有私钥， 所以无法正确的加密。所以它再返回给客户端的数据是无效数据，用公钥解析后会得到乱码。即使攻击者通过多次尝试碰巧能够解析，也无法通过哈希校验。

### Q8: 这样可以防止第三方冒充服务器么
#### BS: 也许可以

- 首先真正的服务器下发的内容，无法被别人篡改。他们有权威机构的公钥，所以可以解密，但是因为没有私钥，所以解密以后的信息无法加密。没有加密或者错误加密的信息被客户端用公钥解密以后，必然无法通过哈希校验。

- 但是，如果你一开始请求的就不是真的服务器，而是一个攻击者，此时的他完全有机会进行中间人攻击。我们知道**第一次握手**的时候服务器会下发用于证明自己身份的证书，这个证书会用预设在设备上的公钥来解密。所以要么是经过认证的证书用权威机构的私钥加密，再用权威机构解密，要么是用非权威机构的私钥加密，然后找不到公钥解密。

- 所以如果不小心安装过非权威机构的根证书，比如黑客提供的恶意证书，这时候设备上就多了一个预设的公钥，那么用恶意私钥加密的证书就能被正常解析出来。所以千万不要随便装根证书，这等于是为那些恶意证书留了一扇门。

- 当然，凡是都有两面性。我们知道 Charles 可以调试 HTTPS 通信，它的原理就是需要用户安装 Charles 的根证书，然后我们的请求会被代理到 Charles 服务器，它下发的 Charles 证书才能被正确解析。另一方面，Charles 会作为客户端，从真正的服务器哪里拿到正确的 https 证书并用于后续通信。幸好 Charles 不是流氓软件，或者它的私钥一旦泄露，对用户都会造成很大的影响。

我可以举一个例子，证书有多个种类，最贵的叫 EV (Extended Validation)，它需要公司营业执照等多个文件才能申请人工审核，好处也很明显，可以在浏览器地址栏左侧准确显示公司名称，比如 Bitbucket 的官网:

EV 证书左侧的名字
这是客户端直连时候的正常现象。但如果你用 Charles 代理，客户端拿到的是 Charles 证书，所以会变成:

代理模式下无法显示
### Q9: HTTPS 握手会影响性能么

- TCP 有三次握手，再加上 HTTPS 的四次握手，会不会影响性能？

#### BS: 影响肯定有，但是可以接受

- 首先，HTTPS 肯定会更慢一点，时间主要花费在两组 SSL 之间的耗时和证书的读取验证上，对称算法的加解密时间几乎可以忽略不计。

- 而且如果不是首次握手，后续的请求并不需要完整的握手过程。客户端可以把上次的加密情况直接发送给服务器从而快速恢复，具体细节可以参考 图解SSL/TLS协议。

- 除此以外，SSL 握手的时间并不是只能用来传递加密信息，还可以承担起客户端和服务器沟通 HTTP2 兼容情况的任务。因此从 HTTPS 切换到 HTTP2.0 不会有任何性能上的开销，反倒是得益于 HTTP2.0 的多路复用等技术，后续可以节约大量时间。

如果把 HTTPS2.0 当做目标，那么 HTTPS 的性能损耗就更小了，远远比不上它带来的安全性提升。

