### 指标找工具

[![sHq57D.png](https://s3.ax1x.com/2021/01/24/sHq57D.png)](https://imgchr.com/i/sHq57D)

### 工具找指标

[![sHLpNQ.png](https://s3.ax1x.com/2021/01/24/sHLpNQ.png)](https://imgchr.com/i/sHLpNQ)

#### 分析套路

[![sHLvx1.png](https://s3.ax1x.com/2021/01/24/sHLvx1.png)](https://imgchr.com/i/sHLvx1)

#### uptime

````
 18:03:55 up 73 days, 17:42,  1 user,  load average: 0.01, 0.06, 0.02
````
- 18:03:55 //当前时间
- up 73 days, 17:42 //系统运行时间
- 1 user //正在登陆用户数
- load average: 0.01, 0.06, 0.02 //过去1分钟，5分钟，15分钟 的平均负载

##### load average

- 单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数目。和CPU使用率没有直接关系。   

### cpu 上下文切换

CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。

1. 进程上下文切换

- 进程上下文切换，是指从一个进程切换到另一个进程运行

- 而系统调用过程中一直是同一个进程在运行，一次系统调用的过程，其实是发生了两次CPU 上下文切换

(1)、根据调度策略，将CPU时间划片为对应的时间片，当时间片耗尽，当前进程必须挂起。

(2)、资源不足的，在获取到足够资源之前进程挂起。

(3)、进程sleep挂起进程。

(4)、高优先级进程导致当前进度挂起

(5)、硬件中断，导致当前进程挂起

2. 线程上下文切换

**线程是调度的基本单位，而进程则是资源拥有的基本单位**

- 当进程只有一个线程时，可以认为进程就属于线程

- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的

- 线程也有自己的私有数据，栈、寄存器等，这些在上下文切换时也需要保存

(1)、不通进程之间的线程上下文切换，其过程和进程上下文切换大致相同。

(2)、进程内部的线程进上下文切换。不需要切换进程的用户资源，只需要切换线程私有的数据和寄存器

3. 中断上下文切换

- 中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件

- 同一个CPU来说，中断处理比进程拥有更高的优先级，中断上下文切换并不会与进程上下文切换同时发生。

#### 中断状态查看

- 中断发生在内核态

- 从 /proc/interrupts 只读文件，/proc 是Linux 的一个虚拟文件系统，用于 内核空间与用户空间之间的通信。

1. 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
   
2. 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
   
3. 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。

### CPU 使用率

- linux 通过 CPU 接拍率（内核中表示为HZ），触发时间中断，使用全局变量 Jiffies 记录开机以来的节拍树。每发生一次中断，jiffies的值就加1

````
grep 'CONFIG_HZ=' /boot/config-$(uname -r)
CONFIG_HZ=1000

````

- 为了方便用户空间程序，内核还提供了一个用户空间节拍率 USER_HZ，它总是固定为 100，也就是 1/100 秒

````
cat /proc/stat | grep ^cpu
cpu  2467635 287 1424282 638899051 25175 0 335 0 0 0
cpu0 2467635 287 1424282 638899051 25175 0 335 0 0 0

````

#### 僵尸进程

- 僵尸进程表示进程已经退出，但它的父进程没有回收该进程所占用的资源

````

# -a 表示输出命令行选项
# p表PID
# s表示指定进程的父进程
$ pstree -aps 3084
systemd,1
  └─dockerd,15006 -H fd://
      └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml
          └─docker-containe,3991 -namespace moby -workdir...
              └─app,4009
                  └─(app,3084)

````

- 僵尸进程出现的原因是父进程没有回收子进程的资源出现的。解决办法是找到父进程，在父进程中处理，使用pstree查父进程，然后查看父进程的源码检查wait()/waitpid()的调用或SIGCHLD信号处理函数的注册

#### 软中断

- 上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作；上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行

- 下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行；而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行

- Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，我们可以查看 proc 文件系统中的 /proc/softirqs  ，观察软中断的运行情况。

### CPU 问题常见指标

#### CPU使用率

CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等

- 用户CPU使用率，包括用户态CPU使用率（user）和 低优先级用户态CPU使用率（nice）,表示CPU用户态运行的时间百分比。用户CPU使用率高，通常说明应用程序比较繁忙

- 系统CPU使用率，表示CPU在内核态运行的时间百分比（不包括中断）。系统CPU使用率高，说明内核比较繁忙。

- 等待I/O 的CPU使用率，通常也称为iowait,表示等待I/O 的时间百分比。iowait高，通常说明系统与硬件设备的I/O 交互时间长

- 软中断和硬中断使用率，分别表示内核调用软中国内地处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断

- 虚拟化环境中用到的窃取CPUs使用率（steal）和 客户CPU使用率（guest）,分别表示被其他虚拟机占用的CPU时间百分比，和客户虚拟机的CPU时间百分比

#### 平均负载

- 它反应了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。

- 理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了

#### 上下文切换

- 无法获取资源而导致的自愿上下文切换；

- 被系统强制调度导致的非自愿上下文切换。

#### CPU缓存命中率

[![sHh6fK.png](https://s3.ax1x.com/2021/01/24/sHh6fK.png)](https://imgchr.com/i/sHh6fK)


由于 CPU 发展的速度远快于内存的发展，CPU 的处理速度就比内存的访问速度快得多。这样，CPU 在访问内存的时候，免不了要等待内存的响应。为了协调这两者巨大的性能差距，CPU 缓存（通常是多级缓存）就出现了。
































