
### 内存结构
[![sjOwSU.md.png](https://s3.ax1x.com/2021/01/26/sjOwSU.md.png)](https://imgchr.com/i/sjOwSU)

#### 指标找工具

[![sjORfK.md.png](https://s3.ax1x.com/2021/01/26/sjORfK.md.png)](https://imgchr.com/i/sjORfK)

#### 工具找指标

[![sjO46e.md.png](https://s3.ax1x.com/2021/01/26/sjO46e.md.png)](https://imgchr.com/i/sjO46e)

#### 排查流程

[![sjO7TI.png](https://s3.ax1x.com/2021/01/26/sjO7TI.png)](https://imgchr.com/i/sjO7TI)

### 内存映射
- linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切的说是访问虚拟内存。

- 虽然每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。

- 并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的

- 内存映射，其实就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系

#### 虚拟内存空间分布

[![sbfwt0.png](https://s3.ax1x.com/2021/01/24/sbfwt0.png)](https://imgchr.com/i/sbfwt0)

1. 只读段，包括代码和常量等。
   
2. 数据段，包括全局变量等。
   
3. 堆，包括动态分配的内存，从低地址开始向上增长。 
   
4. 文件映射段，包括动态库、共享内存等，从高地址开始向下增长。

5. 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。

**其中堆和文件映射端段的内存是动态分配的。比如C标准库的malloc()或者mmap(),就可以分别在堆和文件映射段动态分配内存。**

#### 内存分配与回收

malloc()是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方案：

- brk():小块内存小于128K ,通过移动堆顶的位置来分配内存，这些内存释放后并不会立刻归还系统，而是被缓存起来，这样可以重复使用

- mmap():直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去

内存如果只分配不释放，就会造成内存泄露，甚至会耗尽系统内存。 所以在应用程序用完内存后，还需要调用free()或者unmap(),来是否这些不用的内存。

##### 发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：

- 回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；

- 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；

- 杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程

##### Swap 

Swap 其实就是把一块磁盘空间当成内存来用。它可以把进程暂时不用的数据存储到磁盘中（这个过程称为换出），当进程访问这些内存时，再从磁盘读取这些数据到内存中（这个过程称为换入）。

##### OOM

OOM（Out of Memory），其实是内核的一种保护机制

- 一个进程消耗的内存越大，oom_score 就越大；

- 一个进程运行占用的 CPU 越多，oom_score 就越小

oom_adj 的范围是 [-17, 15]，数值越大，表示进程越容易被 OOM 杀死；数值越小，表示进程越不容易被 OOM 杀死，其中 -17 表示禁止 OOM

#### buffer 和 Cache

````

# 清理文件页、目录项、Inodes等各种缓存
$ echo 3 > /proc/sys/vm/drop_caches

````

- Buffers:内核缓冲区用到的内存，对应的是 /proc/meminfo 中的Buffers值

````
1. buffers 是对原始磁盘块的临时存储，也就是用了缓存磁盘的数据，通常为20MB,这样内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写

2. 既可以用作"将要写入磁盘数据的缓存"，也可以用作"从磁盘读取数据的缓存"

````

- Cache：内核页缓存和Slab用到的内存，对应的是 /proc/meminfo 中的Cached 与 SReclaimable之和

````
1. Cached 是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘

2. Cache 既可以用"从文件读取数据的页缓存"，也可以用作"写文件的页缓存"

````

#### proc 文件系统

- /proc 是 Linux 内核提供的一种特殊文件系统，是用户跟内核交互的接口。比方说，用户可以从 /proc 中查询内核的运行状态和配置选项，查询进程的运行状态、统计数据等，当然，你也可以通过 /proc  来修改内核的配置
- 磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件
- 在读写普通文件时，会经过文件系统，由文件系统负责与磁盘交互；而读写磁盘或者分区时，就会跳过文件系统，也就是所谓的“裸I/O“。

### free

````
[root@jessy ~]# free
              total        used        free      shared  buff/cache   available
Mem:        2040928      266668      651948         604     1122312     1597892
Swap:             0           0           0

````

- total:总内存的大小

- used:已使用内存的大小，包括共享内存

- free:未使用内存的大小

- shared:共享内存大小

- buff/cache ：缓存和缓冲区的大小

- available: 新进程可用内存的大小，不仅包括未使用内存，还包括了可回收的缓存，所以一般比未使用内存更大。

### vmstat

````
[root@jessy ~]# vmstat
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 1615204   1472 153188    0    0     6     6  152   31  0  0 100  0  0

````

- buff 和 cache 就是我们前面看到的 Buffers 和 Cache，单位是 KB

- bi 和 bo 则分别表示块设备读取和写入的大小，单位为块 / 秒。因为 Linux 中块的大小是 1KB，所以这个单位也就等价于 KB/s。


#### 文件和磁盘写：生成一个500MB大小的文件

````
# 通过读取随机设备，生成一个 500MB 大小的文件
$ dd if=/dev/urandom of=/tmp/file bs=1M count=500

# 运行dd命令向磁盘分区/dev/sdb1写入2G数据
$ dd if=/dev/urandom of=/dev/sdb1 bs=1M count=2048
````

````
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1612988   3540 153948    0    0     0     0  222  568  0  0 100  0  0
 0  0      0 1612988   3540 153948    0    0     0     0  220  580  0  0 100  0  0
 0  0      0 1612988   3540 153948    0    0     0     0  224  583  1  0 99  0  0
 0  0      0 1612988   3540 153948    0    0     0     0  221  579  0  0 100  0  0
 0  0      0 1611184   4092 154356    0    0   984     0  364  952  2  2 94  2  0
 0  0      0 1611232   4092 154420    0    0     0     0  283  682  0  0 100  0  0
 0  0      0 1611232   4092 154420    0    0     0     0  237  603  0  1 99  0  0
 0  0      0 1611232   4092 154420    0    0     0     0  232  603  0  0 100  0  0
 1  0      0 1590560   4236 173924    0    0   224     0  415  698  1 13 86  0  0
 1  1      0 1443644   4244 321336    0    0     0 32816 1395  974  0 100  0  0  0
 1  0      0 1302776   4248 462080    0    0     0 127004 1960 1637  1 99  0  0  0
 1  0      0 1156312   4256 608384    0    0     0 159744 1448  742  0 100  0  0  0
 0  0      0 1086176   4256 678868    0    0     0 53248  878  749  1 48 51  0  0
 0  0      0 1086272   4256 678760    0    0     0     0  301  608  0  0 100  0  0
 0  0      0 1086272   4256 678760    0    0     0     0  251  598  0  0 100  0  0
 0  0      0 1086272   4264 678752    0    0     0    32  258  620  0  0 100  0  0
 0  0      0 1086304   4264 678760    0    0     0     0  246  612  0  0 100  0  0
 0  0      0 1086048   4272 679016    0    0     0 139264  317  739  1  2 97  0  0


````
#### 磁盘和文件读

````
# 运行dd命令读取文件数据$ dd if=/tmp/file of=/dev/null

````


````
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1086152   4928 679004    0    0     0     0  216  573  0  0 100  0  0
 0  0      0 1086152   4928 679004    0    0     0     0  219  577  1  0 99  0  0
 0  0      0 1086152   4928 679004    0    0     0     0  230  597  0  0 100  0  0
 0  0      0 1086152   4928 679004    0    0     0     0  350  777  2  1 97  0  0
 0  0      0 1086152   4928 679004    0    0     0     0  259  614  0  0 100  0  0
 0  0      0 1086144   4928 679016    0    0     0     0  269  619  0  0 100  0  0
 0  0      0 1086176   4928 679016    0    0     0     0  274  638  1  1 98  0  0
 0  0      0 1086176   4928 679016    0    0     0     0  263  616  0  0 100  0  0
 0  0      0 1086176   4936 679008    0    0     0    16  249  603  1  0 99  0  0
 0  0      0 1086176   4936 679016    0    0     0     0  252  595  0  0 100  0  0
 0  0      0 1086176   4936 679016    0    0     0     0  249  583  0  0 100  0  0
 0  0      0 1086176   4936 679016    0    0     0     0  256  593  0  1 99  0  0
 0  0      0 1086176   4936 679016    0    0     0     0  258  604  1  0 99  0  0


````

### 内存泄露

1. 没正确回收分配后的内存，导致泄露

2. 访问已分配内存边界的地址，导致程序异常退出

#### 原因

- 栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。

- 堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free() 来释放它们。如果应用程序没有正确释放堆内存，就会造成内存泄漏

- 内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题










