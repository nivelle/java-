

### 表结构

- MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里

- MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中

### innodb_file_per_table

1. 这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；

2. 这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中

````
一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的
````

### 为什么需要重建表

- 如果delete的数据还会被用于MVCC,那么该数据页(二级索引和聚簇索引)
  上的记录不会被物理删除,是被标记删除。只有当该事务不会用于mvcc了,才可以被**purge线程**把之前标记删除的数据真正删除掉.但是即便数据物理删除了,磁盘空间也不会返回给操作系统.


- 可以通过show table status like 't';观察data_free来预估该表的碎片。如果过大,可以用alter table t engine=innodb来清除

- delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。

### 表的重建

- delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的;所以如果要释放表空间，则需要表重建。

- 从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）

- analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；

- optimize table t 等于 recreate+analyze。

````
alter table A engine=InnoDB;// 命令来重建表

````

1. 建立一个临时文件，扫描表 A 主键的所有数据页；

2. 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；

3. 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；

4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态

5. 用临时文件替换表 A 的数据文件。on

[![yYa9Re.md.png](https://s3.ax1x.com/2021/02/06/yYa9Re.md.png)](https://imgchr.com/i/yYa9Re)

- alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了

### 数据库数据存储结构

[![sD9oRA.md.jpg](https://s3.ax1x.com/2021/01/16/sD9oRA.md.jpg)](https://imgchr.com/i/sD9oRA)

- 区（Extent）是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB=1MB

- 段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64
  个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段

- 表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等

页（Page）如果按类型划分的话，常见的有数据页（保存 B+ 树节点）、系统页、Undo
页和事务数据页等。数据页是我们最常使用的页；在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），InnoDB默认是16K

[![sDCKQ1.md.jpg](https://s3.ax1x.com/2021/01/16/sDCKQ1.md.jpg)](https://imgchr.com/i/sDCKQ1)

- 第一部分: 文件通用部分，也就是文件头和文件尾。它们类似集装箱，将页的内容进行封装，通过文件头和文件尾校验的方式来确保页的传输是完整的；文件头中有两个字段，分别是 FIL_PAGE_PREV 和
  FIL_PAGE_NEXT，它们的作用相当于指针，分别指向上一个数据页和下一个数据页。连接起来的页相当于一个双向的链表

- 第二部分: 记录部分，页的主要作用是存储记录，所以“最小和最大记录”和“用户记录”部分占了页结构的主要空间。另外空闲空间是个灵活的部分，当有新的记录插入时，会从空闲空间中进行分配用于存储新记录

-

第三部分：这部分重点指的是页目录，它起到了记录的索引作用，因为在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索，因此在页目录中提供了二分查找的方式，用来提高记录的检索效率

#### B+ 树的索引的记录检索

如果通过 B+ 树的索引查询行记录，首先是从 B+
树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录

### 脏页(刷脏页导致数据库抖动)

- InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。

- 当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：

1. 如果要淘汰的是一个干净页，就直接释放出来复用；

2. 如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用

#### 控制刷脏页的速度，会参考哪些因素呢？

- innodb_io_capacity 这个参数了，它会告诉 InnoDB 你的磁盘能力

1. 脏页比例;

````
参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%;InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字

InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。
````

2. redo log 写盘速度。

[![yJ0RC8.md.png](https://s3.ax1x.com/2021/02/06/yJ0RC8.md.png)](https://imgchr.com/i/yJ0RC8)