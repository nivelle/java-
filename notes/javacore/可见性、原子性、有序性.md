### 并发编程问题的根源

#### 缓存导致可见性问题

- 多核系统存在多级缓存

- 可见性的定义: 一个线程对共享变量的修改，另外一个线程能够立刻看到

#### 线程切换带来的原子性问题

- 高级编程语言的一个操作可能涉及多个cpu指令

- 操作系统做任务切换，可以发生在任何一条cpu指令执行完

- 原子性定义：一个或者多个操作在CPU 执行过程中不被中断

````
count+=1;

1. 把变量从内存加载到CPU寄存器
2. 在寄存器中执行 +1 操作
3. 将结果写入内存

````

#### 编译优化导致的有序性问题

````
public class DoubleCheck {

    static DoubleCheck doubleCheck;

    static DoubleCheck getInstance() {
        if (doubleCheck == null) {
            synchronized (DoubleCheck.class) {
                if (doubleCheck == null) {
                    doubleCheck = new DoubleCheck();
                }
            }
        }
        return doubleCheck;
    }
}

````

##### 双重检查方式构建一个单例对象是，在new 一个实例的过程被编译器优化为以下步骤：

- 分配一块内存M

- 将M 的地址赋值给 instance 变量（若此时发生线程切换）

- 最后在内存 M 上初始化 对象

### Happens-Before 规则

- 前面一个操作的结果对后续操作是可见的。

- Happens-Before 是一种编译规范，编译器实现是按照这个规范实现的，是对编译优化的一种约束，优化后的代码也要遵守该规则

1.  
