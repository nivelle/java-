### 并发编程问题的根源

#### 缓存导致可见性问题

- 多核系统存在多级缓存

- 可见性的定义: 一个线程对共享变量的修改，另外一个线程能够立刻看到

#### 线程切换带来的原子性问题

- 高级编程语言的一个操作可能涉及多个cpu指令

- 操作系统做任务切换，可以发生在任何一条cpu指令执行完

- 原子性定义：一个或者多个操作在CPU 执行过程中不被中断

````
count+=1;

1. 把变量从内存加载到CPU寄存器
2. 在寄存器中执行 +1 操作
3. 将结果写入内存

````

#### 编译优化导致的有序性问题

````
public class DoubleCheck {

    static DoubleCheck doubleCheck;

    static DoubleCheck getInstance() {
        if (doubleCheck == null) {
            synchronized (DoubleCheck.class) {
                if (doubleCheck == null) {
                    doubleCheck = new DoubleCheck();
                }
            }
        }
        return doubleCheck;
    }
}

````

##### 双重检查方式构建一个单例对象是，在new 一个实例的过程被编译器优化为以下步骤：

- 分配一块内存M

- 将M 的地址赋值给 instance 变量（若此时发生线程切换）

- 最后在内存 M 上初始化 对象

### Happens-Before 规则

- 前面一个操作的结果对后续操作是可见的。

- Happens-Before 是一种编译规范，编译器实现是按照这个规范实现的，是对编译优化的一种约束，优化后的代码也要遵守该规则

1. 程序顺序性规则: 前面的操作Happens-Before于后续的任意操作

2. volatile变量规则：对一个volatile变量的写操作，Happens-Before于后续对这个volatile变量的读操作

3. 传递性规则:如果 A Happens-Before B，且B Happens-Before C，那么 A Happens-Before C 

4. 线程 start() 规则:  如果线程A 调用线程B的start()方法，那么该start()操作Happens-Before 于线程B中的任意操作。

5. 线程join()规则：主线程A 等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join方法返回），主线程能看到子线程的操作。

6. 线程中断规则： 对线程interrupt()方法调用happens-before于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。








































