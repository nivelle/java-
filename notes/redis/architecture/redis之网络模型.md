### 单线程的redis

- redis 是单线程:主要是指redis的网络IO和键值对读写都是由一个线程来完成的，这也是redis对外提供键值存储服务的主要流程。

- redis 其他功能，持久化、异步删除、集群数据同步，其实是由额外的线程来完成的

#### 为什么使用单线程

- 多线程创建本身需要开销

- 多线程编程模式面临的共享资源的并发访问控制问题，需要引入同步原语。

#### 单线程为什么快

- 大部分操作在内存中完成，同时采用了高效的数据结构

- 多路复用机制的使用

### redis 网络模型

#### 基本网络模型

[![yaVjCq.md.jpg](https://s3.ax1x.com/2021/02/08/yaVjCq.md.jpg)](https://imgchr.com/i/yaVjCq)

- accept():监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数
- recv():从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()

#### 基于多路复用的高性能I/O模型

- 在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。

- 内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

[![yaetYR.md.jpg](https://z3.ax1x.com/2021/02/08/yaetYR.md.jpg)](https://imgtu.com/i/yaetYR)

1. 多个FD就是多个套接字

2. redis网络框架调用epoll机制，让内核监听这些套接字；

3. redis线程不会阻塞在某一个特定的监听或已连接套接字上，也就是不会阻塞在某一个特定的客户端请求处理上

4. select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数

##### epoll回调机制

````
所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，一旦监测到fd上有请求到达时，就会触发相应的事件，当相应的事件发生时会调用回调方法。

这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。
````

5. 这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。

6. Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。

### redis单线程处理IO请求的性能瓶颈

- 任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：

  1、操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；

  2、使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；

  3、大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；

  4、淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；

  5、AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；

  6、主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；

- 并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。