### AOF持久化

aof 持久化是通过保存redis服务器所执行的写命令来记录数据库状态的

- AOF(append only file) 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。

- 被写入AOF文件的所有命令都是以redis的命令请求协议格式保存的,因为redis命令请求协议是纯文本格式,所以我们可以直接打开一个AOF文件,观察里面的内容.

- 服务器在启动时,可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态

#### AOF持久化的实现

##### 先执行命令后写日志的好处和风险

- 避免出现记录错误命令的情况，写日志不对命令做检查
- 不会阻塞当前的写操作

---

- 如果刚执行完一个命令，还没来的及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险
- 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。

````
AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了
````

##### AOF持久化功能的实现可分为命令追加(append),文件写入,文件同步(sync)三个步骤

[![yaDvJs.md.jpg](https://s3.ax1x.com/2021/02/09/yaDvJs.md.jpg)](https://imgchr.com/i/yaDvJs)

##### 第一步:命令追加

- 当AOF持久化功能处于打开状态时,服务器在执行完一个写命令后,会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾:

```

struct redisServer{
	//AOF缓冲区
	sds aof_buf;
};


```

##### 第二步: AOF文件的写入与同步

- Redis的服务器进程就是一个事件循环,这个循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复,而时间事件则负责执行像serverCron函数这样需要定时运行的函数.

- 因为服务器在处理文件事件时可能会执行写命令,使得一些内容被追加到
  aof_buf缓冲区里面,所以在服务器每次结束一个事件循环之前,它都会调用flushAppendOnlyFile函数,考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面.

##### 每当服务器常规任务函数被执行、 或者事件处理器被执行时,aof.c/flushAppendOnlyFile 函数都会被调用,这个函数执行以下两个工作：

- WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件。
- SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。

```
def eventLoop():

 while true:

 //处理文件事件,接收,命令请求以及发送命令回复
 //处理命令请求时可能会有新内容追缴到aof_buf缓冲区中
 processFileEvents()
 //处理时间事件
 processTimeEvents()
 //考虑是否将aof_buf中的内容写入和保存到AOF文件里面
 flushAppendOnlyFile()
```

#### flushAppendOnlyFile函数的行为有服务器配置的appendfsync选项的值来决定,各个不同值产生的行为如下:

appendfsync选项的值 | flushAppendOnlyFile函数的行为 | 影响
--- | --- | ---
Always | 同步写回:每个命令执行完,将aof_buf缓冲区中的所有内容写入并同步到AOF文件,将日志写回磁盘 | 写入和保存都由主进程执行，两个操作都会阻塞主进程。
Everysec | 每秒写回: 先把命令写到aof_buf缓冲区,每隔一秒,把缓冲区的内容写入磁盘,并且这个同步操作时又一个线程专门负责执行 | 写入操作由主进程执行,阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。
No | 将aof_buf缓冲区中的所有内容写入到AOF文件,但并不对AOF文件进行同步,何时同步由操作系统来决定 |  写入和保存都由主进程执行，两个操作都会阻塞主进程。

- 因为阻塞操作会让 Redis 主进程无法持续处理请求,所以一般说来,阻塞操作执行得越少、完成得越快,Redis 的性能就越好。

- 不保存模式的保存操作只会在AOF 关闭或 Redis 关闭时执行,或者由操作系统触发,在一般情况下,这种模式只需要为写入阻塞,因此它的写入性能要比后面两种模式要高,当然,这种性能的提高是以降低安全性为代价的：
  在这种模式下,如果运行的中途发生停机,那么丢失数据的数量由操作系统的缓存冲洗策略决定。

- **默认为everysec**

(1) Always : 在这种模式下，每次执行完一个命令之后,WRITE 和 SAVE 都会被执行。另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。

(2) Everysec: SAVE 原则上每隔一秒钟就会执行一次,因为 SAVE 操作是由后台子线程调用的,所以它不会引起服务器主进程阻塞。

在实际运行中,程序在这种模式下对 fsync 或 fdatasync 的调用并不是每秒一次,它和调用 flushAppendOnlyFile 函数时 Redis 所处的状态有关。

````
根据以上说明可以知道,在“每一秒钟保存一次”模式下,如果在情况 1 中发生故障停机,那么用户最多损失小于 2 秒内所产生的所有数据。

如果在情况 2 中发生故障停机,那么用户损失的数据是可以超过 2 秒的。
````

(3) no:在这种模式下,每次调用 flushAppendOnlyFile 函数,WRITE 都会被执行,但 SAVE 会被略过。

在这种模式下,SAVE 只会在以下任意一种情况中被执行：

- Redis 被关闭
- AOF 功能被关闭
- 系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）

这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。

模式| WRITE 是否阻塞？|SAVE 是否阻塞|停机时丢失的数据量 ---|--- AOF_FSYNC_NO| 阻塞 | 阻塞 | 操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。 AOF_FSYNC_EVERYSEC
| 阻塞 | 不阻塞 | 一般情况下不超过 2 秒钟的数据。 AOF_FSYNC_ALWAYS | 阻塞 |阻塞 | 最多只丢失一个命令的数据。

---------------

### AOF重写

- 虽然Redis将生成新的AOF文件替换旧AOF文件的功能命名为'AOF文件重写',但实际上,AOF文件重写并不需要对现有的AOF文件进行任何读取,分析或者写入操作,这个功能是通过读取服务器当前的数据库状态来实现的.

-
为了解决AOF文件体积膨胀的问题,redis提供了AOF文件重写功能,通过该功能,redis服务器可以创建一个新的AOF文件来替代现有的AOF文件,新旧两个AOF文件保存的数据库状态相同,但新的AOF文件不会包含任何浪费空间冗余命令,所以新的Aof文件体积通常会比旧的AOF文件体积小的多.

- 根据键的类型,使用适当的写入命令来重现键的当前值,这就是 AOF 重写的实现原理。

[![ya7cad.md.jpg](https://s3.ax1x.com/2021/02/09/ya7cad.md.jpg)](https://imgchr.com/i/ya7cad)

#### AOF 后台重写

AOF 重写程序可以很好地完成创建一个新 AOF 文件的任务,但是,在执行这个程序的时候,调用者线程会被阻塞。很明显,作为一种辅佐性的维护手段,Redis 不希望 AOF 重写造成服务器无法处理请求,所以 Redis 决定将 AOF
重写程序放到（后台）子进程里执行,这样处理的最大好处是：

1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求。
2. 子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。

#### AOF重写过程的写入问题

- 因为子进程在进行 AOF 重写期间,主进程还需要继续处理命令,而新的命令可能对现有的数据进行修改,这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。 为了解决这个问题,Redis 增加了一个 AOF 重写缓存,这个缓存在
  fork 出子进程之后开始启用,Redis 主进程在接到新的写命令之后,除了会将这个写命令的协议内容追加到现有的 AOF 文件之外,还会追加到这个缓存中 当子进程在执行 AOF 重写时,主进程需要执行以下三个工作：

1. 处理命令请求。
2. 将写命令追加到现有的 AOF 文件中。
3. 将写命令追加到 AOF 重写缓存中。

- 这样一来可以保证:

1. 现有的 AOF 功能会继续执行，即使在 AOF 重写期间发生停机，也不会有任何数据丢失。
2. 所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。

- 当子进程完成 AOF 重写之后,它会向父进程发送一个完成信号,父进程在接到完成信号之后,会调用一个信号处理函数,并完成以下工作：

1. 将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。
2. 对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。

当步骤 1 执行完毕之后,现有 AOF 文件、新 AOF 文件和数据库三者的状态就完全一致了。 当步骤 2 执行完毕之后,程序就完成了新旧两个 AOF 文件的交替。

- 这个信号处理函数执行完毕之后,主进程就可以继续像往常一样接受命令请求了。 在整个 AOF 后台重写过程中,只有最后的写入缓存和改名操作会造成主进程阻塞,在其他时候,AOF 后台重写都不会对主进程造成阻塞,这将 AOF
  重写对性能造成的影响降到了最低。

#### AOF重写触发条件

每次当 serverCron 函数执行时,它都会检查以下条件是否全部满足,如果是的话,就会触发自动的 AOF 重写：

- 没有 BGSAVE 命令在进行。
- 没有 BGREWRITEAOF 在进行。
- 当前 AOF 文件大小大于 **server.aof_rewrite_min_size** （默认值为 1 MB）。
- 当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。默认情况下,增长百分比为 100%,也即是说,如果前面三个条件都已经满足,并且当前 AOF 文件大小比最后一次 AOF
  重写时的大小要大一倍的话,那么触发自动 AOF 重写。

#### AOF重写过程的阻塞问题

问题1，Redis采用fork子进程重写AOF文件时，潜在的阻塞风险包括：fork子进程 和 AOF重写过程中父进程产生写入的场景，下面依次介绍。

a、fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程，老师文章写的是拷贝所有内存数据给子进程，我个人认为是有歧义的），fork采用操作系统提供的写时复制(Copy On Write)
机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写时复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。

b、fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(
Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis
log中看到父进程重新申请了多大的内存空间。

问题2，AOF重写不复用AOF本身的日志，一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis
AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。

----------------

#### AOF文件的载入与数据还原

- aof文件包含了重建数据库状态所需的所有写命令,所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态.

Redis读取AOF文件并还原数据库状态的详细步骤如下:

(1) 创建一个不带网络连接的伪客户端:
因为Redis的命令只能在客户端上下文中执行,而载入AOF文件时所使用的命令直接来源于aof文件而不是网络连接,所以服务器使用一个没有网络连接的伪客户端来执行AOF文件保存的写命令,伪客户端执行命令效果和带网络客户端执行命令的效果完全一样.

(2) 从aof文件中分析并读取出一条写命令

(3) 使用伪客户端执行被读出的写命令

(4) 一直执行步骤2和步骤3,直到AOF文件中所有写命令都被处理完毕为止

为了避免对数据的完整性产生影响,在服务器载入数据的过程中,只有和数据库无关的订阅与发布功能可以正常使用,其他命令一律返回错误。

-----------------

### RDB

- RDB（redis database） 将数据库的快照（snapshot）以二进制的方式保存到磁盘中;RDB持久化保存数据库状态的方法是将键值对保存到RDB文件中

- RDB持久化既可以手动执行,也可以根据服务器配置选项定期执行,该功能可以将某个时间点上的数据库状态保存到一个RDB文件中.

- RDB持久化功能生成的RDB文件是一个经过压缩的二进制文件,通过该文件还可以还原成RDB文件时的数据库状态.

- 在 Redis 运行时,RDB 程序将当前内存中的数据库快照保存到磁盘文件中,在 Redis 重启动时,RDB 程序可以通过载入 RDB 文件来还原数据库的状态。

#### RDB保存

#### SAVE

- 当 save 执行时,Redis 服务器是阻塞的,所以当 SAVE 正在执行时,新的 SAVE、BGSAVE 或 BGREWRITEAOF 调用都不会产生任何作用。只有在上一个 SAVE 执行完毕、 Redis
  重新开始接受请求之后,新的 SAVE、BGSAVE 或 BGREWRITEAOF 命令才会被处理。

- save:save 命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求:

```
redis > save
ok
```

#### BGSAVE

- 如果 BGSAVE 正在执行，那么 BGREWRITEAOF 的重写请求会被延迟到 BGSAVE 执行完毕之后进行，执行 BGREWRITEAOF 命令的客户端会收到请求被延迟的回复。

- 如果 BGREWRITEAOF 正在执行，那么调用 BGSAVE 的客户端将收到出错信息，表示这两个命令不能同时执行。

- BGREWRITEAOF 和 BGSAVE 两个命令在操作方面并没有什么冲突的地方,不能同时执行它们只是一个性能方面的考虑: 并发出两个子进程,并且两个子进程都同时进行大量的磁盘写入操作,这怎么想都不会是一个好主意。

- bgSave:命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程(父进程)继续处理命令请求，redis RDB文件生成的默认配置

```

redis>bgSave
Background saving started
```

- 创建RDB文件的实际工作由rdb.c/rdbSave函数完成,SAVE命令和BGSAVE命令会以不同的方式调用这个函数.

```
def SAVE();
//创建RDB文件
rdbSave();
def BGSAVE(){
	pid =fork();
	if pid ==0;
	//子进程付出创建RDB文件
	rdbSave();
	//完成之后向父进程发送信号
	single_parent()
  elif pid > 0 :
  //父进程继续处理命令请求,并通过轮询等待子进程信号
  handle_request_and_wait_signal()
  else:
  //处理出错情况
  handle_fork_error();
}

```

和使用SAVE命令或者BGSAVE命令创建RDB文件不同,RDB文件的载入工作是在服务器启动时自动执行的,所以Redis并没有专门用于载入RDB文件的命令,只要Redis服务器在启动时检测到RDB文件的存在,它就会自动载入RDB文件.

#### RDB bgSave保存过程

[![yaXfRs.md.jpg](https://s3.ax1x.com/2021/02/09/yaXfRs.md.jpg)](https://imgchr.com/i/yaXfRs)

- 避免阻塞和正常处理写操作并不是一回事。此时，主线程的确没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据

- Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作

-
子进程复制了主线程的页表，所以通过页表映射，能读到主线程的原始数据，而当有新数据写入或数据修改时，主线程会把新数据或修改后的数据写到一个新的物理内存地址上，并修改主线程自己的页表映射。所以，子进程读到的类似于原始数据的一个副本，而主线程也可以正常进行修改。

- fork本身这个操作执行时，内核需要给子进程拷贝主线程的页表。如果主线程的内存大，页表也相应大，拷贝页表耗时长，会阻塞主线程。

- bgsave保存RDB时，如果有写请求，主线程会把新数据写到新的物理地址，此时的阻塞会来自于主线程申请新内存空间以及复制原数据。

#### 自动间隔性保存

- redis允许用户通过设置服务器的save选项,让服务器每隔一段时间就自动执行一次BGSAVE命令.用户可以通过save选项设置多个保存条件,但只要其中任意一个条件满足,服务器就会执行BGSAVE命令:

例如.如果我们提供以下选项:

```
save 900 1 //服务器在900秒之内,对数据进行了至少一次修改

save 300 10 //服务器在300秒内,对数据库进行了至少10次修改

save 60 10000 //服务器在60内,对数据库至少进行了10000次修改

```

#### 设置保存条件

- saveparams属性是一个数组,数组中的每个元素都是一个saveparam结构,每个saveparam结构都保存了一个save选项设置的保存条件

- dirty计数器记录上一次成功执行SAVE命令或者BGSAVE命令之后,服务器对数据库状态(服务器中的所有数据库)进行了多少次修改(包括写入,删除,更新等操作)

- lastsave 属性是一个UNIX时间戳,记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间.

- 当服务器成功执行了一个数据库修改命令后,程序就会对dirty计数器进行更新:命令修改了多少次数据库,dirty计数器的值就增加多少.

- redis服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次,该函数对正在运行的服务器进行维护,它的其中一项工作就是检查save选项所设置的保存条件是否已经满足,如果满足的话,就执行BGSAVE命令.

#### 频繁保存RDB的风险

- 风险一：频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。

- 风险二：，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave
  子进程，这就会频繁阻塞主线程了

### redis4.0 持久化改进

- Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作
- 快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销

--------

### 持久化文件的载入

- 在载入期间,服务器每载入 1000 个键就处理一次所有已到达的请求,不过只有 PUBLISH、SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE
  五个命令的请求会被正确地处理,其他命令一律返回错误。 等到载入完成之后,服务器才会开始正常处理所有命令。

```
发布与订阅功能和其他数据库功能是完全隔离的，前者不写入也不读取数据库，所以在服务器载入期间，订阅与发布功能仍然可以正常使用，而不必担心对载入数据的完整性产生影响。

```

- 另外,因为 AOF 文件的保存频率通常要高于 RDB 文件保存的频率,所以一般来说,AOF 文件中的数据会比 RDB 文件中的数据要新。

- 因此,如果服务器在启动时,打开了 AOF 功能,那么程序优先使用 AOF 文件来还原数据。 只有在 AOF 功能未打开的情况下,Redis 才会使用 RDB 文件来还原数据。

- **服务器在载入RDB文件期间,会一直处于阻塞状态,直到载入工作完成为止**

#### 数据结构

**RDB 文件的组织方式如下:**

```
+-------+-------------+-----------+-----------------+-----+-----------+
| REDIS | RDB-VERSION | SELECT-DB | KEY-VALUE-PAIRS | EOF | CHECK-SUM |
+-------+-------------+-----------+-----------------+-----+-----------+

                      |<-------- DB-DATA ---------->|
```                      

**键值对在 RDB 文件中的组织方式如下：**

```
+----------------------+---------------+-----+-------+
| OPTIONAL-EXPIRE-TIME | TYPE-OF-VALUE | KEY | VALUE |
+----------------------+---------------+-----+-------+
```

RDB 文件使用不同的格式来保存不同类型的值。

#### 载入持久化选项

redis提供了两种不同的持久化方法来将数据存储到硬盘里.

##### RDB文件载入过期键处理

1. 在执行save或者BGSAVE命令创建一个新的RDB文件时,程序会对数据库中的键进行检查,已经过期的键不会被保存到新创建的RDB文件中.因此,数据库中包含过期键不会对生成新的文件造成影响.

2. 在启动Redis服务器时,如果服务器开启了RDB功能,那么服务器将对RDB文件进行载入:

- 如果服务器以主服务器模式运行,那么在载入RDB文件时,程序会对文件中保存的键进行检查,未过期的键会被载入到数据库中,而过期的键则会被忽略

- 如果以从服务器模式运行,那么在载入RDB文件时,文件中保存的所有键,不论是否过期,都会被载入数据库中,不过,因为主从服务器在进行数据库同步的时候,从服务器的数据库就会被清空,所以一般来讲,过期键对载入RDB文件的从服务器也没影响.

##### AOF文件载入过期键处理

- 当服务器以AOF持久化模式运行时,如果数据库中的某个键已经过期,但它还没有被惰性删除或者定期删除,那么AOF文件不会因为这个过期键而产生任何影响.

- 当过期键被惰性删除或者定期删除之后,程序会向AOF文件追加一条DEL命令,来显示地记录该键已经被删除.

````
举个例子,如果客户端使用get message命令,试图访问过期的message键,那么服务器执行以下三个动:

- 从数据库中删除message键

- 追加一条del  message命令道AOF文件

- 向执行get命令的客户端返回空回复
`````

##### AOF重写过期键处理

- 和生成RDB文件时类似,在执行AOF重写的过程中,程序会对数据库中的键进行检查,已过期的键不会被保存到重写后的AOF文件中

------

### 复制过期键处理

当服务器运行在复制模式下时,从服务器的过期键删除动作由主服务器控制:

- 主服务器在删除一个过期键之后,会显示地向所有从服务器发送一个DEL命令,告知从服务器删除这个过期键

- 从服务器在执行客户端发送的读命令时,即使碰到过期键也不会将过期键删除,而是继续像处理未过期的键一样来处理过期键

- 从服务器只有在接到主服务器发来的DEL命令之后,才会删除过期键

-------

### 总结

- rdbSave 会将数据库数据保存到 RDB 文件，并在保存完成之前阻塞调用者。

- SAVE 命令直接调用 rdbSave,阻塞 Redis 主进程； BGSAVE 用子进程调用 rdbSave,主进程仍可继续处理命令请求。

- SAVE 执行期间,AOF 写入可以在后台线程进行,BGREWRITEAOF 可以在子进程进行，所以这三种操作可以同时进行。

- 为了避免产生竞争条件,BGSAVE 执行时,SAVE 命令不能执行。

- 为了避免性能问题,BGSAVE 和 BGREWRITEAOF 不能同时执行。

- 调用 rdbLoad 函数载入 RDB 文件时，不能进行任何和数据库相关的操作，不过订阅与发布方面的命令可以正常执行，因为它们和数据库不相关联。



