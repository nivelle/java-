### 载入持久化选项

redis提供了两种不同的持久化方法来将数据存储到硬盘里.

## RDB

在执行save或者BGSAVE命令创建一个新的RDB文件时,程序会对数据库中的键进行检查,已经过期的键不会被保存到新创建的RDB文件中.因此,数据库中包含过期键不会对生成新的文件造成影响.

#### 载入RDB文件

在启动Redis服务器时,如果服务器开启了RDB功能,那么服务器将对RDB文件进行载入:

- 如果服务器以主服务器模式运行,那么在载入RDB文件时,程序会对文件中保存的键进行检查,未过期的键会被载入到数据库中,而过期的键则会被忽略

- 如果以从服务器模式运行,那么在载入RDB文件时,文件中保存的所有键,不论是否过期,都会被载入数据库中,不过,因为主从服务器在进行数据库同步的时候,从服务器的数据库就会被清空,所以一般来讲,过期键对载入RDB文件的从服务器也没影响.

### AOF文件写入

当服务器以AOF持久化模式运行时,如果数据库中的某个键已经过期,但它还没有被惰性删除或者定期删除,那么AOF文件不会因为这个过期键而产生任何影响.

当过期键被惰性删除或者定期删除之后,程序会向AOF文件追加一条DEL命令,来显示地记录该键已经被删除.


举个例子,如果客户端使用get message命令,试图访问过期的message键,那么服务器执行以下三个动:

- 从数据库中删除message键

- 追加一条del  message命令道AOF文件

- 向执行get命令的客户端返回空回复

### AOF重写

和生成RDB文件时类似,在执行AOF重写的过程中,程序会对数据库中的键进行检查,已过期的键不会被保存到重写后的AOF文件中

### 复制

当服务器运行在复制模式下时,从服务器的过期键删除动作由主服务器控制:

- 主服务器在删除一个过期键之后,会显示地向所有从服务器发送一个DEL命令,告知从服务器删除这个过期键

- 从服务器在执行客户端发送的读命令时,即使碰到过期键也不会将过期键删除,而是继续像处理未过期的键一样来处理过期键

- 从服务器只有在接到主服务器发来的DEL命令之后,才会删除过期键

### 数据库通知

数据库通知是redis2.8版本新增加的功能,这个功能可以让客户端通过订阅给定的频道或者模式,来或者数据中键的变化,以及数据中命令的执行情况.

-------

## AOF持久化

aof 持久化是通过保存redis服务器所执行的写命令来记录数据库状态的

- RDB 将数据库的快照（snapshot）以二进制的方式保存到磁盘中。
- AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。

**rdb持久化保存数据库状态的方法是将键值对保存到RDB文件中,而AOF持久化保存数据库状态的方法是将服务器执行的命令保存到文件中.**

被写入AOF文件的所有命令都是以redis的命令请求协议格式保存的,因为redis命令请求协议是纯文本格式,所以我们可以直接打开一个AOF文件,观察里面的内容.

服务器在启动时,可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态,以下就是服务器载入AOF文件并还原数据库状态时打印的日志.

#### AOF持久化的实现

AOF持久化功能的实现可分为命令追加(append),文件写入,文件同步(sync)三个步骤.

- 命令追加

当AOF持久化功能处于打开状态时,服务器在执行完一个写命令后,会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾:


```

struct redisServer{
	//AOF缓冲区

	sds aof_buf;
};


```

- AOF文件的写入与同步

Redis的服务器进程就是一个事件循环,这个循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复,而时间事件则负责执行像serverCron函数这样需要定时运行的函数.

因为服务器在处理文件事件时可能会执行写命令,使得一些内容被追加到 aof_buf缓冲区里面,所以在服务器每次结束一个事件循环之前,它都会调用flushAppendOnlyFile函数,考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面.

##### 每当服务器常规任务函数被执行、 或者事件处理器被执行时， aof.c/flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作：

- WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件。
- SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。

```
def eventLoop():

 while true:

 //处理文件事件,接收,命令请求以及发送命令回复
 //处理命令请求时可能会有新内容追缴到aof_buf缓冲区中

 processFileEvents()

 //处理时间事件
 processTimeEvents()


 //考虑是否将aof_buf中的内容写入和保存到AOF文件里面
 flushAppendOnlyFile()


```

flushAppendOnlyFile函数的行为有服务器配置的appendfsync选项的值来决定,各个不同值产生的行为如下:

appendfsync选项的值 | flushAppendOnlyFile函数的行为 | 影响
--- | --- | ---
always | 将aof_buf缓冲区中的所有内容写入并同步到AOF文件 | 写入和保存都由主进程执行，两个操作都会阻塞主进程。
everysec | 将aof_buf缓冲区中的所有内容写入到AOF文件,如果上次同步AOF文件的时间距离现在超过一秒钟,那么在此对AOF文件进行同步时,并且这个同步操作时又一个线程专门负责执行 | 写入操作由主进程执行，阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。
no | 将aof_buf缓冲区中的所有内容写入到AOF文件,但并不对AOF文件进行同步,何时同步由操作系统来决定 |  写入和保存都由主进程执行，两个操作都会阻塞主进程。

因为阻塞操作会让 Redis 主进程无法持续处理请求， 所以一般说来， 阻塞操作执行得越少、完成得越快， Redis 的性能就越好。

不保存模式的保存操作只会在AOF 关闭或 Redis 关闭时执行， 或者由操作系统触发， 在一般情况下， 这种模式只需要为写入阻塞， 因此它的写入性能要比后面两种模式要高， 当然， 这种性能的提高是以降低安全性为代价的： 在这种模式下， 如果运行的中途发生停机， 那么丢失数据的数量由操作系统的缓存冲洗策略决定。

** 默认为everysec **


(1) always : 在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。



(2) everysec: SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。注意， 在上一句的说明里面使用了词语“原则上”， 在实际运行中， 程序在这种模式下对 fsync 或 fdatasync 的调用并不是每秒一次， 它和调用 flushAppendOnlyFile 函数时 Redis 所处的状态有关。


根据以上说明可以知道， 在“每一秒钟保存一次”模式下， 如果在情况 1 中发生故障停机， 那么用户最多损失小于 2 秒内所产生的所有数据。

如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。


(3) no:在这种模式下， 每次调用 flushAppendOnlyFile 函数， WRITE 都会被执行， 但 SAVE 会被略过。

在这种模式下， SAVE 只会在以下任意一种情况中被执行：

- Redis 被关闭
- AOF 功能被关闭
- 系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）

这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。

模式| WRITE 是否阻塞？|SAVE 是否阻塞？|停机时丢失的数据量
---|---
AOF_FSYNC_NO| 阻塞 | 阻塞 | 操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。
AOF_FSYNC_EVERYSEC |	阻塞 |	不阻塞	| 一般情况下不超过 2 秒钟的数据。
AOF_FSYNC_ALWAYS |	阻塞	|阻塞 |	最多只丢失一个命令的数据。


---


### AOF文件的载入与数据还原

aof文件包含了重建数据库状态所需的所有写命令,所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态.

Redis读取AOF文件并还原数据库状态的详细步骤如下:

- 创建一个不带网络连接的伪客户端:因为Redis的命令只能在客户端上下文中执行,而载入AOF文件时所使用的命令直接来源于aof文件而不是网络连接,所以服务器使用一个没有网络连接的伪客户端来执行AOF文件保存的写命令,伪客户端执行命令效果和带网络客户端执行命令的效果完全一样.

- 从aof文件中分析并读取出一条写命令

- 使用伪客户端执行被读出的写命令

- 一直执行步骤2和步骤3,直到AOF文件中所有写命令都被处理完毕为止

为了避免对数据的完整性产生影响， 在服务器载入数据的过程中， 只有和数据库无关的订阅与发布功能可以正常使用， 其他命令一律返回错误。

### AOF重写

虽然Redis将生成新的AOF文件替换旧AOF文件的功能命名为'AOF文件重写',但实际上,AOF文件重写并不需要对现有的AOF文件进行任何读取,分析或者写入操作,这个功能时通过读取服务器当前的数据库状态来实现的.

为了解决AOF文件体积膨胀的问题,redis提供了AOF文件重写功能,通过该功能,redis服务器可以创建一个新的AOF文件来替代现有的AOF文件,新旧两个AOF文件保存的数据库状态相同,但新的AOF文件不会包含任何良妃空间冗余命令,所以新的Aof文件体积通常会比旧的AOF文件体积小的多.


根据键的类型， 使用适当的写入命令来重现键的当前值， 这就是 AOF 重写的实现原理。

### AOF 后台重写

AOF 重写程序可以很好地完成创建一个新 AOF 文件的任务， 但是， 在执行这个程序的时候， 调用者线程会被阻塞。很明显， 作为一种辅佐性的维护手段， Redis 不希望 AOF 重写造成服务器无法处理请求， 所以 Redis 决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是：

1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求。
2. 子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。

不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。

为了解决这个问题， Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中

换言之， 当子进程在执行 AOF 重写时， 主进程需要执行以下三个工作：

- 处理命令请求。
- 将写命令追加到现有的 AOF 文件中。
- 将写命令追加到 AOF 重写缓存中。

这样一来可以保证：

- 现有的 AOF 功能会继续执行，即使在 AOF 重写期间发生停机，也不会有任何数据丢失。
- 所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。

当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：

- 将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。
- 对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。

当步骤 1 执行完毕之后， 现有 AOF 文件、新 AOF 文件和数据库三者的状态就完全一致了。

当步骤 2 执行完毕之后， 程序就完成了新旧两个 AOF 文件的交替。

这个信号处理函数执行完毕之后， 主进程就可以继续像往常一样接受命令请求了。 在整个 AOF 后台重写过程中， 只有最后的写入缓存和改名操作会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。

以上就是 AOF 后台重写， 也即是 BGREWRITEAOF 命令的工作原理。

#### 重写触发条件

每次当 serverCron 函数执行时， 它都会检查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写：

- 没有 BGSAVE 命令在进行。
- 没有 BGREWRITEAOF 在进行。
- 当前 AOF 文件大小大于 server.aof_rewrite_min_size （默认值为 1 MB）。
- 当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。

默认情况下， 增长百分比为 100% ， 也即是说， 如果前面三个条件都已经满足， 并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话， 那么触发自动 AOF 重写。

-----------------



### RDB

- RDB持久化既可以手动执行,也可以根据服务器配置选项定期执行,该功能可以将某个时间点上的数据库状态保存到一个RDB文件中.

- RDB持久化功能生成的RDB文件是一个经过压缩的二进制文件,通过该文件还可以还原成RDB文件时的数据库状态.

在 Redis 运行时， RDB 程序将当前内存中的数据库快照保存到磁盘文件中， 在 Redis 重启动时， RDB 程序可以通过载入 RDB 文件来还原数据库的状态。


### RDB保存

- SAVE:SAVE命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求:

```
redis > SAVE
ok

```

- BGSAVE:命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程(父进程)继续处理命令请求:


```

redis>BGSAVE
Background saving started

```

创建RDB文件的实际工作由rdb.c/rdbSave函数完成,SAVE命令和BGSAVE命令会以不同的方式调用这个函数.

```
def SAVE();


//创建RDB文件
rdbSave();


def BGSAVE(){
	pid =fork();

	if pid ==0;

	//子进程付出创建RDB文件

	rdbSave();

	//完成之后向父进程发送信号
	single_parent()

  elif pid > 0 :

  //父进程继续处理命令请求,并通过轮询等待子进程信号
  handle_request_and_wait_signal()
  else:
  //处理出错情况
  handle_fork_error();
}

```

和使用SAVE命令或者BGSAVE命令创建RDB文件不同,RDB文件的载入工作是在服务器启动时自动执行的,所以Redis并没有专门用于载入RDB文件的命令,只要Redis服务器在启动时检测到RDB文件的存在,它就会自动载入RDB文件.


#### 因为AOF文件的更新频率比RDB文件更新频率高:

- 如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件还原数据库状态

- 只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态.



** 服务器在载入RDB文件期间,会一直处于阻塞状态,直到载入工作完成为止**


#### SAVE

当 SAVE 执行时， Redis 服务器是阻塞的， 所以当 SAVE 正在执行时， 新的 SAVE 、 BGSAVE 或 BGREWRITEAOF 调用都不会产生任何作用。只有在上一个 SAVE 执行完毕、 Redis 重新开始接受请求之后， 新的 SAVE 、 BGSAVE 或 BGREWRITEAOF 命令才会被处理。

#### BGSAVE

在执行 SAVE 命令之前， 服务器会检查 BGSAVE 是否正在执行当中， 如果是的话， 服务器就不调用 rdbSave ， 而是向客户端返回一个出错信息， 告知在 BGSAVE 执行期间， 不能执行 SAVE 。这样做可以避免 SAVE 和 BGSAVE 调用的两个 rdbSave 交叉执行， 造成竞争条件。

如果 BGSAVE 正在执行，那么 BGREWRITEAOF 的重写请求会被延迟到 BGSAVE 执行完毕之后进行，执行 BGREWRITEAOF 命令的客户端会收到请求被延迟的回复。
如果 BGREWRITEAOF 正在执行，那么调用 BGSAVE 的客户端将收到出错信息，表示这两个命令不能同时执行。

BGREWRITEAOF 和 BGSAVE 两个命令在操作方面并没有什么冲突的地方， 不能同时执行它们只是一个性能方面的考虑： 并发出两个子进程， 并且两个子进程都同时进行大量的磁盘写入操作， 这怎么想都不会是一个好主意。


#### 自动间隔性保存

redis允许用户通过设置服务器的save选项,让服务器每隔一段时间就自动执行一次BGSAVE命令.用户可以通过save选项设置多个保存条件,但只要其中任意一个条件满足,服务器就会执行BGSAVE命令:

例如.如果我们提供以下选项:

```
save 900 1

save 300 10

save 60 10000

```

那么只要满足以下条件中的任意一个,BGSAVE命令就会被执行:

- 服务器在900秒之内,对数据进行了至少一次修改

- 服务器在300秒内,对数据库进行了至少10次修改

- 服务器在60内,对数据库至少进行了10000次修改


#### 设置保存条件

redis服务器启动时,用户可以通过制定配置文件或者传入启动参数的方式设置SAVE选项,如果用户没有主动设置SAVE选项,那么服务器会为SAVE选项设置默认条件:

```
save 900 1

save 300 10

save 60 10000

```
接着,服务器会根据save选项所设置的保存条件,设置服务器状态rediServer结构的saveparams属性:

```
struct redisServer{
	
	//记录了保存条件的数组
	struct saveparam * saveparams;
}


```
saveparams属性是一个数组,数组中的每个元素都是一个saveparam结构,每个saveparam结构都保存了一个save选项设置的保存条件:

```
struct saveparam{
	time_t seconds;

	int changes;
}


```



####  dirty计数器和lastsave属性

除了saveparams数组之外,服务器状态还维持着一个dirty计数器,以及一个lastsave属性:

- dirty计数器记录上一次成功执行SAVE命令或者BGSAVE命令之后,服务器对数据库状态(服务器中的所有数据库)进行了多少次修改(包括写入,删除,更新等操作)

- lastsave属性是一个UNIX时间戳,记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间.


当服务器成功执行了一个数据库修改命令后,程序就会对dirty计数器进行更新:命令修改了多少次数据库,dirty计数器的值就增加多少.


#### 检查保存条件是否满足

redis服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次,该函数对正在运行的服务器进行维护,它的其中一项工作就是检查save选项所设置的保存条件是否已经满足,如果满足的话,就执行BGSAVE命令.


### 载入

在载入期间， 服务器每载入 1000 个键就处理一次所有已到达的请求， 不过只有 PUBLISH 、 SUBSCRIBE 、 PSUBSCRIBE 、 UNSUBSCRIBE 、 PUNSUBSCRIBE 五个命令的请求会被正确地处理， 其他命令一律返回错误。 等到载入完成之后， 服务器才会开始正常处理所有命令。

```
发布与订阅功能和其他数据库功能是完全隔离的，前者不写入也不读取数据库，所以在服务器载入期间，订阅与发布功能仍然可以正常使用，而不必担心对载入数据的完整性产生影响。

```

另外， 因为 AOF 文件的保存频率通常要高于 RDB 文件保存的频率， 所以一般来说， AOF 文件中的数据会比 RDB 文件中的数据要新。

因此， 如果服务器在启动时， 打开了 AOF 功能， 那么程序优先使用 AOF 文件来还原数据。 只有在 AOF 功能未打开的情况下， Redis 才会使用 RDB 文件来还原数据。

### 数据结构

**RDB 文件的组织方式如下:**

```
+-------+-------------+-----------+-----------------+-----+-----------+
| REDIS | RDB-VERSION | SELECT-DB | KEY-VALUE-PAIRS | EOF | CHECK-SUM |
+-------+-------------+-----------+-----------------+-----+-----------+

                      |<-------- DB-DATA ---------->|
```                      




**键值对在 RDB 文件中的组织方式如下：**

```
+----------------------+---------------+-----+-------+
| OPTIONAL-EXPIRE-TIME | TYPE-OF-VALUE | KEY | VALUE |
+----------------------+---------------+-----+-------+
```

RDB 文件使用不同的格式来保存不同类型的值。

## 总结

- rdbSave 会将数据库数据保存到 RDB 文件，并在保存完成之前阻塞调用者。

- SAVE 命令直接调用 rdbSave ，阻塞 Redis 主进程； BGSAVE 用子进程调用 rdbSave ，主进程仍可继续处理命令请求。

- SAVE 执行期间， AOF 写入可以在后台线程进行， BGREWRITEAOF 可以在子进程进行，所以这三种操作可以同时进行。

- 为了避免产生竞争条件， BGSAVE 执行时， SAVE 命令不能执行。

- 为了避免性能问题， BGSAVE 和 BGREWRITEAOF 不能同时执行。

- 调用 rdbLoad 函数载入 RDB 文件时，不能进行任何和数据库相关的操作，不过订阅与发布方面的命令可以正常执行，因为它们和数据库不相关联。



