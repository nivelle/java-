[![DFrbkT.png](https://s3.ax1x.com/2020/11/15/DFrbkT.png)](https://imgchr.com/i/DFrbkT)

### 字符串对象

字符串对象的编码可以是 **int** , **raw** 或者 **embstr**.

- 如果一个字符串对象保存的是整数值,并且这个整数值可以用long类型来表示,那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面(将void *转换成long),并将字符串对象的编码设置为int;

- 如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节,那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值,并将对象的编码设置为raw.


```
127.0.0.1:6379> set intValue 1 
OK
127.0.0.1:6379> object encoding intValue
"int"
```

```
redis> set story "LONG,long ago there lived a king ..."
OK

redis>STRLEN story
(integer) 37

redis>OBJECT ENCODING story
"raw"

```

````
127.0.0.1:6379> set pi 3.14
OK
127.0.0.1:6379> object encoding pi
"embstr"

````

- **如果字符串对象保存的是一个字符串值,并且这个字符串值长度小于等于32字节,那么字符串对象将使用embstr编码的方式来保存这个字符串值**


#### embstr编码的字符串对象来保存短字符串有以下好处:

- embstr 编码将创建字符串对象所需要的内存分配次数从raw编码次数降为一次

- 释放 embstr 编码的字符串对象只需要调用一次内存释放函数,而释放raw编码的字符串对象需要调用两次内存释放函数

- 因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面,所以这种编码的字符串对象必raw编码的字符串对象更好地利用缓存带来的优势


**redis没有为embstr编码的字符串对象编写任何相应的修改程序,所以embstr编码的字符串实际上是只读的,当对其执行修改命令时,程序会先将对象的编码从embstr转换成raw,然后再执行修改命令.**


### 列表对象

列表对象的编码可以 **zipList** 或者 **linkedList**.

1. ziplist 编码的列表对象使用压缩列表作为底层实现,每个压缩列表节点(entry)保存了一个列表元素.当列表对象元素不大,每个元素也不大的时候,就采用ziplist存储。但当数据量过大时就ziplist就不是那么好用了。
因为为了保证他存储内容在内存中的连续性，插入的复杂度是O(N)，即每次插入都会重新进行realloc。


2. linkedLis编码的列表使用双端链表作为底层实现,每个双端链表节点都保存了一个字符串对象,而每个字符串对象都保存了一个列表元素.它的结构比较简单，节点中存放pre和next两个指针，还有节点相关的信息。
当每增加一个node的时候，就需要重新malloc一块内存。


##### 编码转换

当列表对象同时满足以下两个条件时,使用ziplist编码

- 列表对象保存所有字符串长度都小于64字节;

- 列表对象保存的元素数量小于512个;

其余列表对象使用linkedList编码.

### 哈希对象

哈希对象的编码可以是 **ziplist** 或者 **hashtable**.

ziplist编码的哈希对象使用压缩列表作为底层实现,每当有新的键值对要加入到哈希对象时,程序会先将保存了建的压缩列表节点推入到压缩列表表尾,然后再将保存了值的压缩列表节点推入到压缩列表表尾:

- 保存了同一键值对的两个节点总是紧挨在一起,保存键的节点在前,保存值的节点在后
- 先添加到哈希对象中的键值对会被方在压缩列表的表头方向,而后添加到哈希对象总的键值对会被放在压缩列表的表尾方向


1. 如果profile键的值对象使用的是ziplust编码，则使用压缩列表

2. hashtable编码的哈希对象使用字典作为底层实现,哈希对象中的每个键值对都使用一个字典键值对来保存:

- 字典的每个键都是一个字符串对象,对象中保存了键值对的键;
- 字典的每个值都是一个字符串对象,对象中保存了键值对的值.


##### 编码转换

当哈希对象可以同时满足两个条件时,哈希对象使用ziplist编码:

- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
- 哈希对象保存的键值对数量小于512个;不能满足这两个条件的哈希对象需要使用hashtable编码

**这两个条件的上限值是可以修改,具体hash-max-ziplist-value和hash-max-ziplist-entries**

对于使用ziplist编码的列表对象来说,当使用ziplist编码所需的两个条件的任意一个不能被满足时,对象的编码转换操作会被执行,原本保存在压缩列表里面的所有键值对都会被转义并保存到字典里面,对象的编码也会从ziplist变为hashtable.


**若包含的键值对数量过多也会引起的编码转换**

### 集合对象

集合对象的编码可以是intset或者hashtable

intset编码的集合对象使用整数集合作为底层实现,集合对象包含的所有元素都被保存在整数集合里面.

hashtable编码的集合对象使用字典作为底层实现,字典的每个键都是一个字符串对象,每个字符串对象包含了一个集合元素,而字典的值则全部被设置为null


### 编码的转换

当集合对象可以同时满足以下两个条件时,对象使用intset编码:

- 集合对象保存的所有元素是整数
- 集合对象保存的元素数量不超过512个

其余均使用hashtable编码.对于使用intset编码的集合对象来说,当任意一个条件不能满足时,将会执行转码操作,转换为字典保存,若向只包含整数元素的集合对象添加一个字符串元素,集合短信的编码转移操作就会被执行.


### 有序集合对象

有序集合的编码可以是ziplist或者skiplist

ziplist编码的压缩列表对象使用压缩列表作为底层实现,每个集合元素使用两个紧挨在一起的压缩列表节点来保存,第一个节点保存元素的成员,第二个元素则保存元素的分值.

压缩列表内的集合元素按照分值从小到大排序,分值小的元素放置在靠近表头的方向,而分值较大的元素则被放置在靠近表尾的方向.

```
redis > ZDD price 8.5 apple 5.0 banana 6.0 cherry

(integer) 3

```


**skiplist编码的有序集合对象使用zset结构作为底层实现,一个zset结构同时也包含一个字典和一个跳跃表"**

```
typedef struct zset{
    zskiplist *zsl;
    dict * dict;
}zset;

```

zset结构中zsl跳跃表按照分值大小保存了所有集合元素,每个跳跃表节点都保存了一个集合元素:跳跃表节点的object属性保存了元素的成员,而跳跃表节点的score属性则保存了元素的分值.


zset结构中的dict字典未有序集合创建了一个从成员到分值的映射,字典中的每个键值对都保存了一个结合元素:字典的键保存了元素的成员,而字典的值则保存了元素的分值

有序集合的每个元素的成员都是一个字符串对象,而每个元素的分值都是一个double类型的浮点数.虽然zset结构同时使用跳跃表和字典来保存有序集合元素,但是这两种数据结构都会通过指针来共享元素的成员和分值,所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值,也不会因此浪费额外的内存.


### 编码的转换

当有序集合对象可以同时满足以下条件时,对象使用ziplist编码:

- 有序集合保存的元素数量小于128个
- 有序集合保存的所有元素成员的长度都小于64字节
