### 简单动态字符串（SDS）

redis是用C编写的内存数据库，但是存储的字串符不是C传统的用字符数组表示的形式，而是自己定义了一套名为简单动态字符串的抽象类型。

````
set msg "hello world"

````

对于上面的存储是简单的String类型，他们底层的数据结构将会是：

- 键(key)是一个字符串对象，对象底层保存着一个字符串"msg"的SDS；

- 值也是一个字符串对象，对象底层页保存着一个“hello world”的sds。

#### SDS定义

每个sds.h/sdshdr结构表示一个SDS值:

```

struct sdshdr{
  //记录buf数组中已经使用的字节的数量
  //等于SDS所保存字符串的长度,不包括 结束符号 '\0'
  int len;
  //记录buf数组中未使用的字节的数量
  int free;

  //字节数组,用于保存字符串
  char buf[];
}

```

[![yNKwNj.png](https://s3.ax1x.com/2021/02/07/yNKwNj.png)](https://imgchr.com/i/yNKwNj)

#####  与C字符串的区别
 
- 获取字符串的长度(O(1)和O(n)):
  
  C字符串使用N+1的字符数组来表示长度为N的字符串，所以获取一个字符串的长度，必须遍历整个字符串数组，记录下\0前的长度。SDS内部维护了一个len的变量，直接记录了字符串的长度，复杂度为O(1).

- 杜绝缓存区溢出：

  C字符串不记录字符串的长度，除了获取长度复杂度高外，还发生缓存区溢出；

````
具体原因通俗说是： C字符串是用字符数组存储的，如果程序中存在两个紧紧挨着的字符数组，

“aaa\0”和“bbb\0”,如果a串减少字符，则不会发生问题，但是如果此时a串继续添加“AA”，但是又忘了重新为a串分配足够的空间由于C字符数组是不记录长度的，则会将修改发生到b串身上，则就发生了字符溢出

````

- 减少修改字符串带来的内存分配次数

1. 空间预分配

当SDS的API对一个SDS进行修改,并且需要读SDS进行空间拓展的时候,程序不仅会为SDS分配修改所必须的空间,还会为SDS分配额外的未使用空间.

(1). 如果对SDS进行修改之后,SDS的长度(也即len属性的值)将小于1MB,那么程序分配和len属性同样大小的未使用空间,这时SDS len属性的值将和free属性的值相同.例如:如果进行修改之后,SDS的len将变成13字节,那么程序也会分配13字节的未使用空间,SDS的buf数组的实际长度将变成13 + 13 +1=27字节(额外的一字节用于保存空字符)
(2). 如果对SDS进行修改之后,SDS的长度将大于等于1MB,那么程序会分配1MB的未使用空间.例如:如果进行修改之后,SDS的len的len将变成30MB,那么程序就会分配1MB的未使用空间,SDS的buf数组的实际长度将为30MB+1MB+1byte.


2. 惰性空间释放

(1). 惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时,程序并不立即使用内存重分配来回收缩短后多出来的字节,而是使用free属性将这些字节的数量记录起来,并等待将来使用.

- 二进制安全

(1). C 字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存想图片，音频，视频，压缩文件这样的二进制数据。
     但是在Redis中，不是靠空字符来判断字符串的结束的，而是通过len这个属性。那么，即便是中间出现了空字符对于SDS来说，读取该字符仍然是可以的


---------------

### 链表(list)

- 链表是list的数据类型底层数据结构，是双向链表，key中存储了链表的头尾指针，可以获取到头尾节点。

- 链表提供了高效的节点重排能力,以及顺序性的节点访问方式,并且可以通过增删节点来灵活地调整链表的长度.

#### 链表数据结构

````
typedef struct list{
    //表头节点
    ListNode * head;
    //表尾节点
    ListNode * tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复制函数，用于复制链表节点所保存的值
    void *(*dup)(void *ptr);
    //节点值释放函数，用于释放链表节点所保存的值
    void (*free)(void *ptr);
    //节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等
    int (*match)(void *ptr,void *key)
}list;

````

- 双端： 链表节点带有prev 和next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是O（N）
- 无环： 头结点的prev和尾节点的next都是执行null，所以访问时指向null即可停止查找。
- 表头和表尾：因为链表带有head指针和tail 指针，程序获取链表头结点和尾节点的时间复杂度为O(1)
- 长度计数器：链表中存有记录链表长度的属性 len

#### 链表节数据结构

```
typedef struct listNode{
    //前置节点
    struct listNode * prev;
    //后置节点
    struct listNode * next;
    //节点的值
    voi * value;
}listNode;

```

[![yNlFhj.png](https://s3.ax1x.com/2021/02/07/yNlFhj.png)](https://imgchr.com/i/yNlFhj)

#### 链表在redis中的应用：

- 当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表键的底层实现

- 发布与订阅，慢查询，监视器

- 使用链表来构建客户端输出缓冲区


----------

### 字典(dictht)

#### 字典定义以及应用

- 字典,又称为符号表,关联数组或映射,是一种用于保存键值对的抽象数据结构.字典中,一个键可以和一个值进行关联,这些关联的键和值就称为键值对.

- 字典中的每个键都是独一无二的,程序可以在字典中根据键查找与之关联的值,或通过键里更新值,或根据键来删除整个键值对.

- redis的数据库就是使用字典作为底层实现的,对数据库的增删查改操作也是构建在对字典的操作之上的.

- 字典还是**哈希键**的底层实现之一,当一个哈希键包含的键值对比较多,又或者键值对中的元素都是比较长的字符串时,redis就会使用字典作为哈希键的底层实现.

#### 字典完整结构

[![yN8Snx.png](https://s3.ax1x.com/2021/02/07/yN8Snx.png)](https://imgchr.com/i/yN8Snx)

```
typedef struct dict{
    //类型特定函数
    dictType * type;
    //私有数据
    void *privadata;
    //哈希表
    dictht ht[2];
    //rehash 索引; 当rehash不在进行时,值为-1
    int trehashidx;
}

```

- type属性和privadata 属性是针对不同类型的键值对,为创建多态字典而设置的;

- type属性是一个指向dictType结构的指针,每个dictType结构保存了一簇用于操作特定类型键值对的函数,redis会为用途不同的字典设置不同的类型特定函数.

- privdata属性则保存了需要传给那些类型特定函数的可选参数

- ht属性是一个包含两个项的数组,数组中的每个项都是一个dict哈希表,一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用.


#### 哈希表

**Redis的字典使用哈希表作为底层实现,一个哈希表里面可以有多个哈希表节点,而每个哈希表节点就保存了字典中的一个键值对.**

```
typedef struct dictht{
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;
    //哈希表大小掩码,用于计算索引值
    //总是等于size-1  => size & sizemask = h / size-1
    unsigned long sizemask;
    //哈希表已有节点的数量
    unsigned long used;
}dictht;

```

- table属性是一个数组,数组中的每个元素都是一个指向dict.h/dictEntry结构的指针,每个dictEntry结构保存着一个键值对.

- size属性记录了哈希表的大小,也即table数组的大小;

- used属性则记录了哈希表目前已有节点的数量.

- sizemask 属性的值总是等于size-1,这个属性和哈希值一起决定一个键应该被放到table数组的那个索引上面.

#### 哈希表节点

哈希表节点使用dictEntry结构表示,每个dictEntry结构都保存着一个键值对:

```
typedef struct dictEnty{
    //键
    void * key;
    //值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    }v;
    //指向下个哈希表节点,形成链表
    struct dictEntry *next;
}dictEntry;


```

- key属性保存着简直对中的键,而v属性则保存着键值对中的值,其中键值对的值可以是一个指针,或者是一个uint64_t整数,又或者是一个int64_t整数.

- next属性是指向另一个哈希表节点的指针,**这个指针可以将多个哈希值相同的键值对连接在一次,以此来解决键冲突的问题**

### rehash 扩容

redis中，每次插入键值对时，都会检查是否需要扩容。如果满足扩容条件，则进行扩容：

1. 如果哈希表ht[0]的大小为0，则初始化字典

2. 如果哈希表ht[0]中保存的**key个数与哈希表大小**的比例已经达到1:1，即保存的节点数已经大于等于哈希表大小 且redis服务当前允许执行rehash

3. 保存的节点数与哈希表大小的**比例**超过了安全阈值(默认值为5)则将哈希表大小扩容为原来的两倍

##### 允许执行扩容rehash的判断

1. 服务器目前在没有执行BGSAVE 和 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于1

2. 服务器目前在执行BGSAVE 或 BGREWRITEAOF 命令，并且哈希表负载因子大于等于5（为了避免在使用子进程过程中进行rehash操作）

- 也就是当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：

(1). 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1

(2). 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5

### rehash 缩容

- 当哈希表保存的key数量与哈希表的大小的比例小于10%时需要缩容。最小容量为4

- 如果当前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，则不进行缩容

#### 渐进式rehash: 拓展和收缩哈希表的工作交由rehash操作来完成,redis对字典的哈希表执行渐进式 rehash 的步骤如下:

- 操作辅助rehash:在redis中每一个增删改查命令中都会判断数据库字典中的哈希表是否正在进行渐进式rehash，如果是则帮助执行一次

-  虽然redis实现了在读写操作时，辅助服务器进行渐进式rehash操作，但是如果服务器比较空闲，redis数据库将很长时间内都一直使用两个哈希表。所以在redis周期函数中，如果发现有字典正在进行渐进式rehash操作，则会花费1毫秒的时间，帮助一起进行渐进式rehash操作

- 为ht[1]哈希表分配空间,这个哈希表的空间大小取决于要执行的操作,以及ht[0]当前包含的键值对数量(也即ht[0].used)
  
  1.如果执行的是拓展操作,那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n(2的n次方幂)
  2.如果执行的是收缩操作,那么ht[1]的大小为第一个大于等于ht[0].used的2^n

- 将保存在ht[0]中的所有键值对rehash到ht[1]上面:rehash指的是重新计算键的哈希值和索引值,然后将键值对放置到ht[1]哈希表的指定位置上.

- 当ht[0]包含的所有键值对都迁移到了ht[1]之后(ht[0]变为空表),释放ht[0],将ht[1]新创建一个空白哈希表,为下一次rehash做准备.

#### 在redis的实现中，没有集中的将原有的key重新rehash到新的槽中，而是分解到各个命令的执行中，以及周期函数中

#### 渐进式rehash小结

在redis中，扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。

以下是哈希表渐进式 rehash 的详细步骤：

（1）为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。

（2）在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。

（3）在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。

（4）随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。

渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。

#### 渐进式 rehash 执行期间的哈希表操作

- 因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。

- 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。

#### 渐进式rehash带来的问题

渐进式rehash避免了redis阻塞，可以说非常完美，但是由于在rehash时，需要分配一个新的hash表，在rehash期间，同时有两个hash表在使用，会使得redis内存使用量瞬间突增，在Redis 满容状态下由于Rehash会导致大量Key驱逐。

-------------
