### 1.简单动态字符串（SDS）

redis是用C编写的内存数据库，但是存储的字串符不是C传统的用字符数组表示的形式，而是自己定义了一套名为简单动态字符串的抽象类型。

````
set msg "hello world"

````

对于上面的存储是简单的String类型，他们底层的数据结构将会是：

- 键(key)是一个字符串对象，对象底层保存着一个字符串"msg"的SDS；

- 值也是一个字符串对象，对象底层页保存着一个“hello world”的sds。

#### SDS定义

每个sds.h/sdshdr结构表示一个SDS值:

```

struct sdshdr{
  //记录buf数组中已经使用的字节的数量
  //等于SDS所保存字符串的长度,不包括 结束符号 '\0'
  int len;
  //记录buf数组中未使用的字节的数量
  int free;

  //字节数组,用于保存字符串
  char buf[];
}

```

[![yNKwNj.png](https://z3.ax1x.com/2021/02/07/yNKwNj.png)](https://imgtu.com/i/yNKwNj)

##### 与C字符串的区别

- 获取字符串的长度(O(1)和O(n)):

````
  C字符串使用N+1的字符数组来表示长度为N的字符串，所以获取一个字符串的长度，必须遍历整个字符串数组，记录下\0前的长度。
  SDS内部维护了一个len的变量，直接记录了字符串的长度，复杂度为O(1).
````
- 杜绝缓存区溢出:C字符串不记录字符串的长度，除了获取长度复杂度高外，还容易发生缓存区溢出；

````
具体原因通俗说是:C字符串是用字符数组存储的，如果程序中存在两个紧紧挨着的字符数组，

“aaa\0”和“bbb\0”,如果a串减少字符，则不会发生问题，但是如果此时a串继续添加“AA”，但是又忘了重新为a串分配足够的空间由于C字符数组是不记录长度的，则会将修改发生到b串身上，则就发生了字符溢出

````

- 减少修改字符串带来的内存分配次数

##### 空间预分配

- 当SDS的API对一个SDS进行修改,并且需要读SDS进行空间拓展的时候,程序不仅会为SDS分配修改所必须的空间,还会为SDS分配额外的未使用空间.
  
  - 如果对SDS进行修改之后,SDS的长度(也即len属性的值)小于1MB,那么程序分配和len属性同样大小的未使用空间,这时SDS len属性的值将和free属性的值相同.
    ````
    例如:如果进行修改之后,SDS的len将变成13字节,那么程序也会分配13字节的未使用空间,SDS的buf数组的实际长度将变成13 + 13 +1=27字节(额外的一字节用于保存空字符)
    ````  
  - 如果对SDS进行修改之后,SDS的长度将大于等于1MB,那么程序会分配1MB的未使用空间.
    ````
    例如:如果进行修改之后,SDS的len的len将变成30MB,那么程序就会分配1MB的未使用空间,SDS的buf数组的实际长度将为30MB+1MB+1byte.
    ````

##### 惰性空间释放

 - 惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时,程序并不立即使用内存重分配来回收缩短后多出来的字节,而是使用free属性将这些字节的数量记录起来,并等待将来使用.

##### 二进制安全

 - C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存想图片，音频，视频，压缩文件这样的二进制数据。
但是在Redis中，不是靠空字符来判断字符串的结束的，而是通过len这个属性。那么，即便是中间出现了空字符对于SDS来说，读取该字符仍然是可以的


---------------

### 2.链表(list)

- 链表是list的数据类型底层数据结构，是双向链表，key中存储了链表的头尾指针，可以获取到头尾节点。

- 链表提供了高效的节点重排能力,以及顺序性的节点访问方式,并且可以通过增删节点来灵活地调整链表的长度.

#### 链表数据结构

````
typedef struct list{
    //表头节点
    ListNode * head;
    //表尾节点
    ListNode * tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复制函数，用于复制链表节点所保存的值
    void *(*dup)(void *ptr);
    //节点值释放函数，用于释放链表节点所保存的值
    void (*free)(void *ptr);
    //节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等
    int (*match)(void *ptr,void *key)
}list;

````

- 双端:链表节点带有prev 和next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是O（N）
- 无环:头结点的prev和尾节点的next都是执行null，所以访问时指向null即可停止查找。
- 表头和表尾:因为链表带有head指针和tail 指针，程序获取链表头结点和尾节点的时间复杂度为O(1)
- 长度计数器:链表中存有记录链表长度的属性 len

#### 链表节点数据结构

```
typedef struct listNode{
    //前置节点
    struct listNode * prev;
    //后置节点
    struct listNode * next;
    //节点的值
    voi * value;
}listNode;

```

[![yNlFhj.png](https://z3.ax1x.com/2021/02/07/yNlFhj.png)](https://imgtu.com/i/yNlFhj)

#### 链表在redis中的应用：

- 当一个列表键包含了**数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时**，redis就会使用链表键的底层实现

- 发布与订阅，慢查询，监视器

- 使用链表来构建客户端输出缓冲区

----------

### 3.字典(dict)

#### 字典定义以及应用

- 字典,又称为符号表,关联数组或映射,是一种用于保存键值对的抽象数据结构.字典中,一个键可以和一个值进行关联,这些关联的键和值就称为键值对.

- 字典中的每个键都是独一无二的,程序可以在字典中根据键查找与之关联的值,或通过键里更新值,或根据键来删除整个键值对.

- redis的数据库就是使用字典作为底层实现的,对数据库的增删查改操作也是构建在对字典的操作之上的.

- 字典还是**哈希键对象**的底层实现之一,**当一个哈希键包含的键值对比较多(大于512),又或者键值对中的元素都是比较长的字符串时(大于64字节)**,redis就会使用字典作为哈希键的底层实现.

#### 字典完整结构

[![yN8Snx.md.png](https://z3.ax1x.com/2021/02/07/yN8Snx.md.png)](https://imgtu.com/i/yN8Snx)

```
typedef struct dict{
    //类型特定函数
    dictType * type;
    //私有数据
    void *privadata;
    //哈希表
    dictht ht[2];
    //rehash 索引; 当rehash不在进行时,值为-1
    int trehashidx;
}

```

- type属性和privadata 属性是针对不同类型的键值对,为创建多态字典而设置的;

- type属性是一个指向dictType结构的指针,每个dictType结构保存了一种用于操作特定类型键值对的函数,redis会为用途不同的字典设置不同的类型特定函数.

- privdata 属性则保存了需要传给那些类型特定函数的可选参数

- ht属性是一个包含两个项的数组,数组中的每个项都是一个dict哈希表,一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用.

#### 哈希表

**Redis的字典使用哈希表作为底层实现,一个哈希表里面可以有多个哈希表节点,而每个哈希表节点就保存了字典中的一个键值对.**

```
typedef struct dictht{
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;
    //哈希表大小掩码,用于计算索引值
    //总是等于size-1  => size & sizemask = h / size-1
    unsigned long sizemask;
    //哈希表已有节点的数量
    unsigned long used;
}dictht;

```

- table属性是一个数组,数组中的每个元素都是一个指向dict.h/dictEntry结构的指针,每个dictEntry结构保存着一个键值对.

- size属性记录了哈希表的大小,也即table[0]数组的size大小;

- used属性则记录了哈希表目前已有节点的数量.

- sizemask 属性的值总是等于size-1,这个属性和哈希值一起决定一个键应该被放到table数组的那个索引上面.

#### 哈希表节点

哈希表节点使用dictEntry结构表示,每个dictEntry结构都保存着一个键值对:

```
typedef struct dictEnty{
    //键
    void * key;
    //值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    }v;
    //指向下个哈希表节点,形成链表
    struct dictEntry *next;
}dictEntry;


```

- key属性保存着简直对中的键,而v属性则保存着键值对中的值,其中键值对的值可以是一个指针,或者是一个uint64_t整数,又或者是一个int64_t整数.

- next属性是指向另一个哈希表节点的指针,**这个指针可以将多个哈希值相同的键值对连接在一次,以此来解决键冲突的问题**

### rehash 扩容

redis中，每次插入键值对时，都会检查是否需要扩容。如果满足扩容条件，则进行扩容：

1. 如果哈希表ht[0]的大小为0，则初始化字典

2. 如果哈希表ht[0]中保存的**key个数与哈希表大小的比例已经达到1:1**，即保存的节点数已经大于等于哈希表数组大小 且redis服务当前允许执行rehash

3. 保存的 **节点数与哈希表大小的比例超过了安全阈值(默认值为5)** 则将哈希表大小扩容为原来的两倍(已经产生hash冲突)

#### 允许执行扩容rehash的判断

1. 服务器目前在没有执行**BGSAVE** 和 **BGREWRITEAOF**命令，并且哈希表的负载因子大于等于1

2. 服务器目前在执行**BGSAVE 或 BGREWRITEAOF**命令，并且哈希表负载因子大于等于5（为了避免在使用子进程过程中进行rehash操作）

- 也就是当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：

(1). 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1

(2). 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5

### rehash 缩容

- 当哈希表保存的key数量与哈希表的大小的比例小于10%时需要缩容。最小容量为4

- 如果当前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，则不进行缩容

#### 渐进式rehash: 拓展和收缩哈希表的工作交由rehash操作来完成,redis对字典的哈希表执行渐进式 rehash 的步骤如下:

- **操作辅助rehash**:在redis中每一个增删改查命令中都会判断数据库字典中的哈希表是否正在进行渐进式rehash，如果是则帮助执行一次

- 虽然redis实现了在读写操作时，辅助服务器进行渐进式rehash操作，但是如果服务器比较空闲，redis数据库将很长时间内都一直使用两个哈希表。
  所以在**redis周期函数**中，如果发现有字典正在进行渐进式rehash操作，则会花费1毫秒的时间，帮助一起进行渐进式rehash操作

- 为ht[1]哈希表分配空间,这个哈希表的空间大小取决于要执行的操作,以及ht[0]当前包含的键值对数量(也即ht[0].used)

  1.如果执行的是拓展操作,那么ht[1]的大小为第一个大于等于ht[0].used*2
  
  2.如果执行的是收缩操作,那么ht[1]的大小为第一个大于等于ht[0].used的2^n

- 将保存在ht[0]中的所有键值对rehash到ht[1]上面:rehash指的是重新计算键的哈希值和索引值,然后将键值对放置到ht[1]哈希表的指定位置上.

- 当ht[0]包含的所有键值对都迁移到了ht[1]之后(ht[0]变为空表),释放ht[0],将ht[1]新创建一个空白哈希表,为下一次rehash做准备.

#### 在redis的实现中，没有集中的将原有的key重新rehash到新的槽中，而是分解到各个命令的执行中，以及周期函数中

#### 渐进式rehash小结

在redis中，扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。为了避免 rehash
对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。

- 以下是哈希表渐进式 rehash 的详细步骤：

（1）为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。

（2）在字典中维持一个索引计数器变量 rehashidx,并将它的值设置为 0 ， 表示 rehash 工作正式开始。

（3）在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash
工作完成之后， 程序将 rehashidx 属性的值增一。

（4）随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。

- 渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。

#### 渐进式 rehash 执行期间的哈希表操作

- 因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行：
  比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。

- 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash
  操作的执行而最终变成空表。

#### 渐进式rehash带来的问题

渐进式rehash避免了redis阻塞，可以说非常完美，但是由于在rehash时，需要分配一个新的hash表，在rehash期间，同时有两个hash表在使用，会使得redis内存使用量瞬间突增，在Redis 满容状态下由于Rehash会导致大量Key驱逐。

-------------

### 4.跳表(skiplist)

- 跳跃表是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的.

- 跳跃表支持平均o(logN),最坏O(N)复杂度的节点查找,还可以通过顺序性操作来批量处理节点.

- redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的元素数量比较多,或者有序集合中元素的成员是比较长的字符串时,redis就会使用跳跃表来作为有序集合键的底层实现.

- Redis 只在两个地方用到了跳跃表，一个是实现有序集合键，另外一个是在集群节点中用作内部数据结构。

- 每个跳表的节点的高度在于1~32之间的随机数

- 在同一个跳表中，多个节点，可以包含相同的分值，但每个节点的对象必须是唯一的。

- 节点按照分值的大小从大到小排序，如果分值相同，则按成员对象大小排序。

[![yNspkj.png](https://z3.ax1x.com/2021/02/07/yNspkj.png)](https://imgtu.com/i/yNspkj)

#### zskiplist 数据结构

````
typedef struct zskiplist {
     //表头节点和表尾节点
     structz skiplistNode *header,*tail;
     //表中节点数量
     unsigned long length;
     //表中层数最大的节点的层数;在redis中定义了跳表的最高高度为32层
     int level;

}zskiplist;

````

#### zskiplistNode(节点)数据结构

````
typedef struct zskiplistNode{
　　　//层,数组结构
     struct zskiplistLevel{
　　　　　//前进指针
        struct zskiplistNode *forward;
　　　　//跨度
        unsigned int span;
    } level[];
　　//后退指针
    struct zskiplistNode *backward;
　　//分值
    double score;
　　//成员对象
    robj *obj;
}

````

- 层:level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针

- 前进指针: 用于指向表尾方向的前进指针

- 跨度：用于记录两个节点之间的距离

- 后退指针：用于从表尾向表头方向访问节点

- 分值和成员：跳跃表中的所有节点都按分值从小到大排序。成员对象指向一个字符串，这个字符串对象保存着一个SDS值

### 5.整数集合(intSet)

- 整数集合是集合建的底层实现之一,当一个集合只包含整数值元素,并且这个集合元素数量不多时,redis就会使用整数集合作为集合建的底层实现.

- 它可以保持类型为int16_t,int32_t或者int64_t的整数,并且保证集合中不会出现重复元素.

#### 整数集合数据结构

````
typedef struct intset{
    //编码方式
    uint32_t enconding;
   // 集合包含的元素数量
    uint32_t length;
    //保存元素的数组    
    int8_t contents[];

}
````

- encoding:用于定义整数集合的编码方式
- length:用于记录整数集合中变量的数量
- contents：用于保存元素的数组，虽然我们在数据结构图中看到，intset将数组定义为int8_t，但实际上数组保存的元素类型取决于encoding

#### 整数集合的升级

在上述数据结构图中我们可以看到，intset 在默认情况下会帮我们设定整数集合中的编码方式，但是当我们存入的整数不符合整数集合中的编码格式时，就需要使用到Redis 中的升级策略来解决

intset 中升级整数集合并添加新元素共分为三步进行：

- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间

![整数集合升级1.png](https://i.loli.net/2021/02/07/ugStFwiChe7qJzI.png)

- 将底层数组现有的所有元素都转换成新的编码格式，重新分配空间

![整数集合升级2.png](https://i.loli.net/2021/02/07/knU6JqLvdYozWet.png)

- 将新元素加入到底层数组中

![整数集合升级3.png](https://i.loli.net/2021/02/07/fAvR2nqDkZm5w13.png)


------

### 6. 压缩列表

- 压缩列表是**列表建**和**哈希键**、**有序集合**的底层实现之一.

- 当一个列表键只有少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么Redis 就会使用压缩列表来做列表键的底层实现

[![yNyMVg.png](https://z3.ax1x.com/2021/02/07/yNyMVg.png)](https://imgtu.com/i/yNyMVg)

1. zlbytes:用于记录整个压缩列表占用的内存字节数

2. zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节，无须遍历整个压缩列表就可以确定表尾节点的地址

3. zllen：记录了压缩列表包含的节点数量

4. entryX：要说列表包含的各个节点

5. zlend：用于标记压缩列表的末端

- 压缩列表是为了节约内存而开发的,由一系列特殊编码的连续内存块组成的顺序型数据结构.一个压缩列表可以包含任意多个节点,每个节点可以保存一个字节数组或一个整数值.

#### 节点成分

##### previous_entry_length

记录了压缩列表中前一个节点的长度.previous_entry_lengtg 属性的长度可以是1字节或5字节:

- 如果前一个节点长度小于254字节,那么previous_entry_length属性长度为1字节:前一个节点的长度就保存在这个字节里面

- 如果前一个节点的长度大于等于254字节,那么previous_entry_length 属性长度为5字节:其中属性的第一个字节会被设置为0xFE,而之后的四个字节则用于保存前一个节点的长度.

#### encoding

节点的encoding属性记录了节点的content属性所保存数据的类型以及长度:

- 一字节,两字节或者五字节长,值得最高位为00,01或者10的是字节数组编码:这种编码表示节点的content属性保存着字节数组,数组的长度由编码除去最高两位之后的其他位记录;

- 一字节长,值的最高位以11开头的是整数编码:这种编码表示节点的content属性保存着整数值,整数值的类型和长度由编码除去最高位之后的其他位记录.

##### content

节点的content属性负责保存这个节点的值,节点的值可以是一个字节数组或者整数,值的类型和长度由节点的encoding属性决定:

- 编码的最高两位00表示节点保存的是一个字节数组;
- 编码的后六位001011记录了字节数组的长度11
- content属性保存着节点的值"hello world"

