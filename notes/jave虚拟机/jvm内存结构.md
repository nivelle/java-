### jvm内存结构

#### 运行时数据区

- java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域

#### jvm主要分为：堆，方法区，程序计数器，虚拟机栈，本地方法栈

[![rtv8C6.png](https://z3.ax1x.com/2020/12/19/rtv8C6.png)](https://imgtu.com/i/rtv8C6)
-------
#### 1.虚拟机栈

![虚拟机栈.png](https://i.loli.net/2020/12/19/ijIaUN8o14AdVRY.png)

- 作用: 存储当前线程执行方法的数据，指令,返回地址

- 虚拟机栈基于线程：在线程生命周期中，参与计算的数据都会频繁出入栈，栈的生命周期和线程一样

- 虚拟机栈的的大小默认值为1M,可用参数 **-Xss**调整大小。

###一个线程内一个方法对应一个栈帧

##### 局部变量表

定义: 用于存储局部变量（一般是方法中的变量）。它的32位的长度为一个槽（slot）,java中的8大基础数据类型，如果是32位，直接占用一个人slot,如果64位就占用两个slot.如果是一个些局部对象，例如object对象，只需要存它的应用地址。（基本数据类型，对象引用，returnAddress类型）

- 编译时已经确定局部变量表，操作数栈大小，可在Class文件中查看；

- 局部变量表已槽位单位，一个slot32位，64位的数据可按高低位占两个slot(基本类型和引用类型占1个slot，long和double占2个slot);

- 方法执行中，虚拟机用局部变量来实现参数传递过程。如果是实例方法，局部变量表第0位存储值默认位方法所属的实例this,其余参数从1开始依次存储；

##### 操作数栈

定义:存放java操作数，栈结构，用来操作数据，操作的元素可以是java任意类型，通过依次执行指令来操作。操作数栈本质上是JVM执行引擎的一个工作区，只有方法执行的时候才会进行数据进栈出栈操作，代码不执行时栈位空。

- 编译时确定大小；
  
- frame创建时，栈为空，可以存java各种类型，long和double占2个栈深；
  
- 操作栈调用其他有返回结果的方法时，会把结果push到栈上（通过操作数栈来进行参数传递）

###### jvm中，基于解释执行的这种方式是基于栈的引擎，这个栈就是操作数栈

``````
在编译程序代码阶段，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的code 属性之中。

因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现

``````

##### 动态链接

- 每个栈帧都包含一个指向**运行时常量池**中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接；
  
- 在类加载阶段中的解析阶段会将符号引用直接转为直接引用，这种转化也称为静态解析。另外一部分在运行是转化为直接引用，这部分成为动态链接

#####  返回地址

- 正常返回(调用程序计数器中的地址作为返回)、

1. 恢复上层方法的局部变量表和操作数栈；
   
2. 把返回值(如果有的化)压入调用者栈帧的操作数栈中；
   
3. 调整程序计数器的值以指向方法调用指令后面的一条指令；

- 异常返回： 通过异常处理表<非栈帧中的>来确定

----

#### 2.程序计数器

- 较小内存空间，当前线程执行代码的行号指示器，各线程间独立存储，互不影响。

- 主要记录线程执行的字节码的地址，入分支、循环、跳转、异常、线程恢复等都依赖计数器

- java是多线程语言，当执行的线程数超过CPU核数时，线程之间会根据时间片轮询争夺CPU资源。如果一个线程的时间片用完了，或者其他原因导致这个线程的CPU资源被提前抢夺，那么这个退出的线程就需要
计数器记录字节码执行的地址或者行号；
  
- 如果是本地方法不需要JVM执行，则不需要计数器。 程序计数器是JVM中唯一不会OOM的内存区域。
------
#### 3.本地方法栈

本地方法栈用于管理本地方法调用，本地方法由C语言实现，本地方法栈和虚拟机栈非常相似的一个区域，它服务的对象是native方法。你甚至可以认为虚拟机栈和本地方法栈是同一个区域。虚拟机规范无强制规定，各版本虚拟机自由实现，HotSpot直接把本地方法栈和虚拟机栈合二为一。

-------

#### 4. 方法区（元空间）

- 方法区是可供各条线程共享的运行时内存区域。

- 它存储了每个类的结构信息,例如运行时常量池（runtime Constant Pool）、字段和方法数据，构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。

- jdk1.7 之前存在于"永久代"中；jdk1.8之后使用元空间实现方法区，并且"字符串常量池" 和 "静态变量"放入了堆中。

- 元空间：方法区与对空间类似，也是一个共享内存区，所以方法区是线程共享的。假如两个线程同时试图访问方法区中的同一个类信息，而这个类还没有装入JVM,那么此时就只允许一个线程区加载它，另外一个线程必须等待。

- 在HotSpot虚拟机中，Java7版本中已经将**静态变量和运行时常量池**转移到了堆中，其余部分则存在JVM的非堆内存中，而Java8版本已经将方法区中实现的永久代去掉了，并用元空间（class
  metadata）代替了之前的永久代，**元空间的存储位置是本地内存**。

##### 元空间代替永久代的好处：

- 融合HotSpot JVM与JRockit VM而做出的努力，因为JRockit没有永久代，所以不需要配置永久代

- 永久代内存经常发生OOM:PermGen。jdk1.7,指定PermGen区大小为8M，由于PermGen中类的元数据信息在每次FullGC的时候都可能被收集，回收率偏低；还有为PermGen分配多大的空间很难确定，PermSize的大小依赖很多因素，比如JVM加载的class总数、常量池的大小、和方法的大小

- 方法区是可供各条线程共享的运行时内存区域。它存储了每个类的结构信息，例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、接口 初始化时用到的特殊方法。

##### 元空间大小参数

- jdk1.7以及之前（初始化和最大值）：-XX:PermSize; -XX:MaxPermSize

- jdk1.8以后（初始化和最大值）：**-XX:MetaspaceSize;-XX:MaxMetaspaceSize**;如果不设置参数的话就只受本机总内存的限制。

##### 运行时常量池

- 运行时常量池是类或接口常量池加载后的运行时表现形式。它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。

- 运行时常量池时方法区的一部分，运行时常量池相对于Class常量池的另外一个重要特征就是具备动态性。

#### 5.堆内存

- 堆是JVM上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆；

- 堆一般设置成可伸缩的；

- 随着对象的频繁创建，堆空间占用越来越多，就需要不定期的堆不再使用的对象进行回收。这个在Java中，就叫做GC(Garbage Collection);

- 对象到底在堆上还是栈上分配，取决于：对象的类型和在Java类中存在的位置；

（1).java对象来说，基本数据类型，普通对象

(2).普通对象--都是堆上分配内存，其他地方使用它的引用（比如局部变量表中）；

(3).基本类型数据（byte,short,int,long,float,double,char,boolean）如果在方法内声明，则在栈分配，其他情况，堆上分配；

##### 堆大小参数

- Xms:堆的最小值
- Xmx:堆的最大值
- Xmn:新生代的大小
- XX:NewSize //新生代最小值
- XX:MaxNewSize //新生代最大值

#### 堆外内存（直接内存）

- jvm在运行时，会从操作系统申请大块的堆内存，进行数据的存储；同时还有虚拟机栈、本地方法栈和程序，这块称之为栈区。操作系统剩余的内存也就是堆外内存。

- 它不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了nio,这块区域会被频繁使用；

- 使用时，分配内存，然后在堆中的directByteBuffer对象直接引用来操作

- 这块内存不受java堆大小限制，但受本季总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM

- 直接内存主要是通过 DirectByteBuffer 申请的内存，可以使用参数MaxDirectMemorySize 来限制它的大小

- 其他堆外内存，主要是指使用了Unsafe或者其他JNI手段直接申请的内存

#### 操作数栈执行细节

[add(int a,int b)执行细节](/Users/nivellefu/IdeaProjects/java-guides/java-base/src/main/java/com/nivelle/base/jdk/jvm/StackFrameDemo.java)

````
/**
 * 编译：javac com\nivelle\base\jdk\StackFrameDemo.java
 * 反编译：javap -p -v com\nivelle\base\jdk\StackFrameDemo.class
 */
public class StackFrame {
    public static void main(String[] args) {
        add(1, 2);
    }

    private static int add(int a, int b) {
        int c = 0;
        c = a + b;
        return c;
    }
}
````

[![rN5ARs.png](https://s3.ax1x.com/2020/12/19/rN5ARs.png)](https://imgchr.com/i/rN5ARs)

### 压缩指针

````
在 Java 虚拟机中，每个 Java 对象都有一个对象头（object header），这个由标记字段和类型指针所构成。其中，标记字段用以存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息，而类型指针则指向该对象的类。

````

- 在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位
- 64 位 Java 虚拟机引入了压缩指针的概念（对应虚拟机选项 **-XX:+UseCompressedOops**，默认开启），将堆中原本 64 位的 Java 对象指针压缩成 32 位的。
- 默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充（padding）
- 在默认情况下，Java 虚拟机中的 32 位压缩指针可以寻址到 2 的 35 次方个字节，也就是 32GB 的地址空间（超过 32GB 则会关闭压缩指针）
- 就算是关闭了压缩指针，Java 虚拟机还是会进行内存对齐。此外，内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间。比如说，Java 虚拟机要求 long 字段、double 字段，以及非压缩指针状态下的引用字段地址为 8
  的倍数
- 字段内存对齐的其中一个原因，是让字段只出现在同一 CPU 的缓存行中

### 字段重排列

- 字段重排列，顾名思义，就是 Java 虚拟机重新分配字段的先后顺序，以达到内存对齐的目的。

- Java 8 还引入了一个新的注释 @Contended，用来解决对象字段之间的虚共享（false sharing）问题。这个注释也会影响到字段的排列。

#### Java 虚拟机中有三种排列方法,但都会遵循如下两个规则:

- 对应 Java 虚拟机选项 **-XX:FieldsAllocationStyle** 默认值为 1

- 如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。 以 long 类为例，它仅有一个 long 类型的实例字段。在使用了压缩指针的 64 位虚拟机中，尽管对象头的大小为 12
  个字节，该 long 类型字段的偏移量也只能是 16，而中间空着的 4 个字节便会被浪费掉。

- 子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。

