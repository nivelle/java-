### 索引

#### 创建唯一索引

```
create unique index uniq_device_no on activity(`device_no`);

```

#### 创建联合索引

```

CREATE INDEX type_device ON activity (`type`,`device_no`);

```

#### 查看索引

```
show index from activity;

+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table       | Non_unique | Key_name       | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| activity |          0 | PRIMARY        |            1 | id          | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          0 | uniq_device_no |            1 | device_no   | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          1 | device         |            1 | type | A         |           2 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          1 | device         |            2 | device_no   | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+

```

#### InnoDB的索引有两类索引，聚集索引(Clustered Index)与普通索引(Secondary Index)。

- InnoDB的每一个表都会有聚集索引 **(叶子节点存储行记录(row)**:

(1)如果表定义了PK，则PK就是聚集索引;

(2)如果表没有定义PK，则**第一个非空unique列是聚集索引**;

(3)否则，InnoDB会创建一个隐藏的**row-id作为聚集索引**；

- 普通索引，叶子节点存储了PK的值；

- 无论使用InnoDB还是 MyISAM 存储引擎，默认都会创建一个主键索引，而创建主键索引默认使用 `B+tree索引`。

1. 如果是 MyISAM 存储引擎，由于MyISAM使用的是`辅助索引`，索引中每一个叶子结点仅仅记录的是每行数据的物理地址，即`行指针`。
  
2. 如果是 InnoDB 存储引擎，使用的是`聚蔟索引`，索引中的叶子节点记录了**主键，事务id,用户事务和MVCC的回流指针以及所有的剩余列**。
  
-----

#### 前缀索引

````

mysql> alter table SUser add index index1(email);
或
mysql> alter table SUser add index index2(email(6));

````

- 定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。

- 索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。

---
## 索引优化

- **尽量避免回表,也即索引覆盖**:索引包含要查询的数据,就不需要通过叶子节点的主键值,再去回表查询数据了,减少了IO操作; select count(*)
  如果不存在辅助索引，此时会通过聚蔟索引来统计行数，如果有辅助索引，则会通过查询辅助索引来统计行数

- **自增字段作为主键优化查询**: 如果使用自增主键，插入数据就会按照顺序添加到当前索引节点位置，不需要移动已经有的数据，当页面写满，就会自动开辟一个新页面。

- **前缀索引优化**: 减少索引字段大小，可以增加一个页中存储的索引项，有效提高索引的查询速度。 在一些大字符串的字段作为索引时，使用前缀索引可以帮助减少索引项的大小。
  `order by 无法使用前缀索引，无法把前缀索引用作覆盖索引`

- **防止索引失效**: 以 %s 开头的的like查询无法利用节点查询数据;使用复合索引时，需要使用索引最左边的列进行查询才可以; `查询条件使用 or 且or的前后条件中有一个列没有索引，那么涉及的索引不会被使用到`。


---

### 数据页纬度的索引结构

![数据库存储空间结构.jpg](https://i.loli.net/2021/08/29/Ne1cZXqiVJbnFHY.jpg)
- **区：一个区=64个页**

- **段**：段是数据库的分配单位，一个表是一个段，一个索引是一个段

- **表空间**：逻辑空间，可以包括多个段，但是一个段仅属于一个表空间。数据库由一个或者多个表空间组成，比如：系统表空间，用户表空间，临时表空间

- innodb 的 innodb_file_per_table 为on,表明每张表都会保存为一个 .idb 文件；

- 页：按类型分为：数据页、系统页、undo页、事务数据页;**innodb默认的页大小为16KB**

#### 普通索引和唯一索引的选择

##### 查询过程

- 对于普通索引来说，查到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满条件的记录

- 对于唯一索引来说，由于索引定义了唯一性，查到第一个满足条件的记录后，就会停止继续检索。

- 因为已经按照页加载到内存，所以这一点性能差距从理论上来说微乎其微。

##### 更新过程

- 对于普通索引的更新，如果目标页不在缓存中，mySQL 做了一个优化，会把更新操作暂时放在一个缓存中 change buffer，**等待下次访问这个数据页或者定时任务merge**这个change buffer到磁盘。

- 因此对于写多读少的非唯一索引，优化效果更加明显。

### 索引的选择

优化器来决定选择什么索引

- 采样统计：InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

- 在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 **innodb_stats_persistent** 的值来选择：

  1. 设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。

  2. 设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16
  
-----

## 二叉查找树

#### 二叉查搜索树特征

- 任意节点左子树不为空,则左子树的值均小于根节点的值;
- 任意节点右子树不为空,则右子树的值均大于于根节点的值;
- 任意节点的左右子树也分别是二叉查找树;
- 没有键值相等的节点;

#### 二叉查找树的局限性:

- 如果节点为有序节点，会退化成连表查找。

- "平衡": 其实就是让整颗树左右看起来比较对称、平衡，不出现左子树很高，右子树很矮的情况。这样整棵树相对高度低，相应的插入、删除，查找操作更高效。

### 平衡二叉树也就是 AVL 树

AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的**平衡二叉树**，平衡条件必须满足（所有节点的左右子树高度差不超过1）。
不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。

#### 局限性

由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。
当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。

----

## B- 树

- 平衡的多路搜索树，在文件系统和数据库系统中多使用B树实现。

- 每一个节点最多包含M个子节点，M称为树的阶

- 每个节点中包含了**关键字**和**子节点指针**

- 如果一个节点包含了x个关键字，那么指针数是x+1

- 所有叶子节点位于同一层

[![s0DLZR.md.jpg](https://z3.ax1x.com/2021/01/15/s0DLZR.md.jpg)](https://imgtu.com/i/s0DLZR)

----
## 红黑树（不严格的二叉查找树）

- 红黑树也是平衡二叉树，但每个节点有一个存储位表示节点的颜色，可以是红或黑。
- 通过对任何一条从根到叶子节点的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度<
  =红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于**搜索，插入，删除操作较多的情况下，用红黑树**

[![sc7UXT.md.jpg](https://i.loli.net/2021/08/31/rLplYZ8m9hoHDc5.jpg)](https://i.loli.net/2021/08/31/rLplYZ8m9hoHDc5.jpg)

#### 红黑树的特征

1. 每个节点非红即黑
2. 根节点是黑的;
3. 如果一个节点是红的，那么它的两儿子都是黑的;
4. 对于任意节点而言，其到`叶子点树NULL指针`的每条路径都包含相同数目的黑节点;
5. 每条路径都包含相同的黑节点;

#### 应用

1. 广泛用于C ++的STL中，地图是用红黑树实现的;
2. **Linux的的进程调度**:用红黑树管理进程控制块，进程的虚拟内存空间都存储在一颗红黑树上，每个虚拟内存空间都对应红黑树的一个节点，左指针指向相邻的虚拟内存空间，右指针指向相邻的高地址虚拟内存空间;
3. **IO多路复用的epoll**:采用红黑树组织管理sockfd，以支持快速的增删改查;
4. **Nginx中用红黑树管理定时器**:因为红黑树是有序的，可以很快的得到距离当前最小的定时器;
5. Java的**TreeMap**的实现;

-----
## B+树

- 非叶子节点仅保存关键字，不存数据记录，记录相关的信息都在叶子节点

- 非叶子节点的关键字会同时存在子节点中，并且是在子节点中所有关键字的最大（或者最小）

- 所有关键字都在叶子节点出现，叶子节点构成一个有序列表，而且**叶子节点本身按照关键字的大小从小到大顺序链接**

[![s0DzRO.md.jpg](https://z3.ax1x.com/2021/01/15/s0DzRO.md.jpg)](https://imgtu.com/i/s0DzRO)

-----
## 数据库索引为什么不适合二叉树

- 平衡二叉树必须满足所有的左右子树高度差不超过1。执行插入还是删除操作只要不满足这个条件，就要通过旋转来保持平衡，而旋转是非常耗时的，所以AVL树仅适合用于查找多的情况

- 二叉树的数据结构，会导致深度比较深，这种瘦高的特性，加大了平均查询磁盘IO次数，随着数据量增多，查询效率会受到影响

## B+ 树和B树在构造和查询性能上的差异

- B+ 树的非叶子节点不直接保存数据，**任何关键字查询都走一条从根节点到叶子节点的查询路线，路径长度一样所以查询效率更加稳定**;

- B+ 树非叶子节点不保存数据，**所以一次IO可以加载更多的节点到内存中**，相对IO次数更低，所以磁盘读写代价更低

- B+ 树数据都存储在叶子节点，非叶子节点均为索引，故方便扫库，只需要扫一遍叶子节点即刻，但B树因为非叶子节点还存储着数据，我们要得到具体的数据，需要进行一次中序遍历来扫，所以B+树更适合在区间查询的情况。