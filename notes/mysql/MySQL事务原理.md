### 事务

#### 事务的启动

- 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。

- set autocommit=0，这个命令会将这个线程的事务自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback
  语句，或者断开连接。

- 很多语言的第三方库都是使用连接池维持可复用的长连接来保持与mysql的链接，需注意，长连接并不意味着长事务，需要判断是否将autocommit设置成了0.

```
第一步:start transaction;
第二步:添加事务的SQL语句
第三步:commit or rollback;
```
----
### mysql 四种隔离级别

隔离级别是用来描述事务之间关系的一种机制。

- **读未提交**: 一个事务还没提交时，它做的变更就能被别的事务看到。

- **读提交**: 一个事务提交之后，它做的变更才会被其他事务看到

- **可重复读**: 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的

- **可序列化**: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

#### 隔离级别核心概念

- 在 MySQL 中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，但不能解决幻读问题

- 当隔离级别为可重复读的时候,就避免了不可重复读,这是因为一个事务只在第一次 SELECT 的时候会获取一次 `Read View`,而后面所有的 SELECT 都会复用这个 `Read View`

- 在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT 查询都会获取一次 `Read View`

 **RC和RR事务隔离级别是基于多版本并发控制(MVCC),底层实现为undoLog来实现高性能事务。**

- **MVCC对普通select不加锁,如果读取的数据正在执行delete或者update，这时读取操作不会等待排他锁释放，而是利用 MVCC 读取该数据的快照(数据快照是基于undoLog实现的)**

- 可重复读的核心就是`一致性读`（consistent read);而**事务更新数据的时候，只能用当前读**。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

#### 幻读问题的原因以及解决方法

- 产生幻读的原因是:行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是 **next_key lock**。
  跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系

- **在读已提交的情况下，InnoDB 只采用记录锁(Record Locking),因此会出现幻读的情况**

- 在可重复读隔离级别下, 普通的查询是快照读, 是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。

- **幻读仅仅指的是插入行,修改行不算幻读;**

**可重复读情况下才有间隙锁,你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。**

### 长事务问题

- 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

- 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库

----

## MVCC 多版本并发控制的特征

1. **读写之间阻塞的问题:** 通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力

2. **降低了死锁的概率:** 这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行

3. **解决一致性读的问题:** 一致性读也被称为快照读,当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果

----
### 快照读

- 不加锁的简单的select都属于快照读

### 当前读

##### 当前读就是读取最新数据，而不是历史版本的数据。加锁的 select 或者对数据进行增删改都会进行当前读

- update 更新操作其实分为两个步骤： 当前读，然后更新操作

- select 加上 lock in share mode(S锁，共享锁) 或者 for update (X锁，排他锁)

### 多版本原理

- 事务版本号: 每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。

- 行记录的隐藏列
  - `db_row_id`：隐藏的行 ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率
  - `db_trx_id`：操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID
  - `db_roll_ptr`：回滚指针，也就是指向这个记录的 `undo log` 指针

#### readView 的工作原理
**Read View 保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度你可以理解为 Read View 保存了不应该让这个事务看到的其他的事务 ID 列表**

- `trx_ids`:系统当前正在活跃的事务ID集合
- `low_limit_id`:活跃的事务中最大的事务ID
- `up_limit_id`:活跃的事务中最小的事务ID
- `creator_trx_id`:创建这个Read View 的事务ID

[![sBqpF0.md.png](https://z3.ax1x.com/2021/01/16/sBqpF0.md.png)](https://imgtu.com/i/sBqpF0)

##### 假设当前有事务 creator_trx_id 想要读取某个行记录，这个行记录的事务 ID 为 trx_id

- 如果 trx_id < 活跃的最小事务 ID（up_limit_id）,也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是**可见**的。

- 如果 trx_id > 活跃的最大事务 ID（low_limit_id）,这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务**不可见**

- 如果 up_limit_id < trx_id < low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态， 因此我们需要在 trx_ids
  集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。 否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见。

##### 一个普通读读的流程

- 首先获取事务自己的版本号,也就是事务 ID；
- 获取 Read View；
- 查询得到的数据`当前值`，然后与 Read View 中的事务版本号进行比较
- 如果不符合ReadView 规则. 就需要从Undo Log 中获取历史快照`想前通过回滚指针找到目标版本`
- 最后返回符合规则的数据

**MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见**

##### MVCC如何解决不可重复读和幻读

- 在可重复读的隔离级别下，InnoDB 可以通过 `Next-Key 锁` 和 `MVCC` 来解决幻读问题。

- 在可重复读的情况下，天然解决不可重复读


---
## 事务优化原则

- 尽可能使用低级别事务隔离

- 避免行锁升级到表锁

- 控制事务大小，减少锁定的资源量和锁定时间长度（小事务，懒事务）,避免长事物

- 尽量使用主键更新

- 设置锁等待超时等待参数

- 如果事务中需要锁多个行,要把最可能造成锁冲突、最可能影响并发读的锁尽量往后放,因为这个锁是在事务提交的时长才释放， 如果一进来就锁住，那么这个事务就很可能成为一个长事务；