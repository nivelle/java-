### 索引

#### 创建唯一索引

```
create unique index uniq_device_no on activity(`device_no`);

```

#### 创建联合索引

```

CREATE INDEX type_device ON activity (`type`,`device_no`);

```

#### 查看索引

```
show index from activity;

+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table       | Non_unique | Key_name       | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| activity |          0 | PRIMARY        |            1 | id          | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          0 | uniq_device_no |            1 | device_no   | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          1 | device         |            1 | type | A         |           2 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          1 | device         |            2 | device_no   | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+

```

#### InnoDB的索引有两类索引，聚集索引(Clustered Index)与普通索引(Secondary Index)。

- InnoDB的每一个表都会有聚集索引 **(叶子节点存储行记录(row)**:

(1)如果表定义了PK，则PK就是聚集索引;

(2)如果表没有定义PK，则**第一个非空unique列是聚集索引**;

(3)否则，InnoDB会创建一个隐藏的**row-id作为聚集索引**；

- 普通索引，叶子节点存储了PK的值；

- 无论使用InnoDB还是 MyISAM 存储引擎，默认都会创建一个主键索引，而创建主键索引默认使用 `B+tree索引`。

1. 如果是 MyISAM 存储引擎，由于MyISAM使用的是`辅助索引`，索引中每一个叶子结点仅仅记录的是每行数据的物理地址，即`行指针`。
  
2. 如果是 InnoDB 存储引擎，使用的是`聚蔟索引`，索引中的叶子节点记录了**主键，事务id,用户事务和MVCC的回流指针以及所有的剩余列**。
  
-----

#### 前缀索引

````

mysql> alter table SUser add index index1(email);
或
mysql> alter table SUser add index index2(email(6));

````

- 定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。

- 索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。

---
## 索引优化

- **尽量避免回表,也即索引覆盖**:索引包含要查询的数据,就不需要通过叶子节点的主键值,再去回表查询数据了,减少了IO操作; select count(*)
  如果不存在辅助索引，此时会通过聚蔟索引来统计行数，如果有辅助索引，则会通过查询辅助索引来统计行数

- **自增字段作为主键优化查询**: 如果使用自增主键，插入数据就会按照顺序添加到当前索引节点位置，不需要移动已经有的数据，当页面写满，就会自动开辟一个新页面。

- **前缀索引优化**: 减少索引字段大小，可以增加一个页中存储的索引项，有效提高索引的查询速度。 在一些大字符串的字段作为索引时，使用前缀索引可以帮助减少索引项的大小。
  `order by 无法使用前缀索引，无法把前缀索引用作覆盖索引`

- **防止索引失效**: 以 %s 开头的的like查询无法利用节点查询数据;使用复合索引时，需要使用索引最左边的列进行查询才可以; `查询条件使用 or 且or的前后条件中有一个列没有索引，那么涉及的索引不会被使用到`。


---

### 数据页纬度的索引结构

![数据库存储空间结构.jpg](https://i.loli.net/2021/08/29/Ne1cZXqiVJbnFHY.jpg)
- **区：一个区=64个页**

- **段**：段是数据库的分配单位，一个表是一个段，一个索引是一个段

- **表空间**：逻辑空间，可以包括多个段，但是一个段仅属于一个表空间。数据库由一个或者多个表空间组成，比如：系统表空间，用户表空间，临时表空间

- innodb 的 innodb_file_per_table 为on,表明每张表都会保存为一个 .idb 文件；

- 页：按类型分为：数据页、系统页、undo页、事务数据页;**innodb默认的页大小为16KB**

#### 普通索引和唯一索引的选择

##### 查询过程

- 对于普通索引来说，查到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满条件的记录

- 对于唯一索引来说，由于索引定义了唯一性，查到第一个满足条件的记录后，就会停止继续检索。

- 因为已经按照页加载到内存，所以这一点性能差距从理论上来说微乎其微。

##### 更新过程

- 对于普通索引的更新，如果目标页不在缓存中，mySQL 做了一个优化，会把更新操作暂时放在一个缓存中 change buffer，**等待下次访问这个数据页或者定时任务merge**这个change buffer到磁盘。

- 因此对于写多读少的非唯一索引，优化效果更加明显。

### 索引的选择

优化器来决定选择什么索引

- 采样统计：InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

- 在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 **innodb_stats_persistent** 的值来选择：

  1. 设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。

  2. 设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16