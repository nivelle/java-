### 表结构

- MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里

- MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中

### innodb_file_per_table

1. 这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；

2. 这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中

````
一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的
````

### 为什么需要重建表

- 如果delete的数据还会被用于MVCC,那么该数据页(二级索引和聚簇索引)
  上的记录不会被物理删除,是被标记删除。只有当该事务不会用于mvcc了才可以被**purge线程**把之前标记删除的数据真正删除掉.但是即便数据物理删除了,磁盘空间也不会返回给操作系统.
  
- 可以通过**show table status like 't'**,观察`data_free`来预估该表的碎片。如果过大,可以用**alter table t engine=innodb**来清除

- delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。

### 表的重建

- delete 命令其实只是把记录的位置,或者数据页标记为了“可复用”,但磁盘文件的大小是不会变的,所以如果要释放表空间，则需要表重建。

- 从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）

- analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；

- `optimize` table t 等于 recreate+analyze。

````
alter table A engine=InnoDB;// 命令来重建表

````

1. 建立一个临时文件，扫描表 A 主键的所有数据页；

2. 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；

3. 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；

4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态

5. 用临时文件替换表 A 的数据文件。on

![数据重建.png](https://i.loli.net/2021/08/30/WfZlOe4cDuy2ULr.png)

- alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了

