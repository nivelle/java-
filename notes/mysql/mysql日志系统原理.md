### mysql 逻辑架构

[![sfBoMd.md.png](https://s3.ax1x.com/2021/01/20/sfBoMd.md.png)](https://imgchr.com/i/sfBoMd)

### 性能配置

- –skip-grant-tables :跳过权限验证

- 增删改数据（DML),修改表结构的操作（DDL)

- set global slow_query_log = on; //开启慢查询日志

- 如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢？

1. 设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数,减少 binlog
   的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。

2. 将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。

3. 将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。

---

### mysql 日志

- redo log(重做日志)

1. redo log 是 InnoDB 存储引擎层的日志,**记录的是这个页做了什么改动**;

2. 在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了, 然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到WAL即 **
   Write Ahead Logging**技术，他的关键点是先写日志，再写磁盘。

3. redo log日志的大小是固定的，即记录满了以后就从头循环写;记录满时要停止数据库更新操作,转而将日志刷到磁盘;

4. 可以根据redo log日志进行恢复,也就达到了 crash-safe

- binlog(归档日志)。

1. binlog是MySQL Server层记录的日志,属于逻辑日志

2. 是以二进制的形式记录的是这个**语句的原始逻辑**，依靠binlog是没有crash-safe能力的

3. Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有

- undoLog

[![sBHSns.png](https://s3.ax1x.com/2021/01/16/sBHSns.png)](https://imgchr.com/i/sBHSns)

1. 回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的 db_trx_id，也是那个时间点操作这个数据的事务 ID。 这样如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找

redoLog | bingLog
---|---
属于innoDB层面 | 属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求
物理日志，记录该数据页更新的内容| 逻辑日志，记录的是这个更新语句的原始逻辑
循环写，日志空间大小固定| 追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖
作为异常宕机或者介质故障后的数据恢复使用|可以作为恢复数据使用，主从复制搭建

---

redoLog | undoLog
---|---
用来恢复提交后的物理数据页(恢复数据页,且只能恢复到最后一次提交的位置) | 记录事务开始前的状态,用来回滚行记录到某个版本;undo log一般是逻辑日志，根据每行记录进行记录。
确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘,在重启mysql服务的时候,根据redo log进行重做,从而达到事务的持久性这一特性。| 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

### 一条更新语句的执行过程(二阶段提交)

update T set c=c+1 where ID=2;

- 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

- 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据

- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

- 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

- 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

---

#### 慢日志

- SHOW VARIABLES LIKE 'slow_query%';

````
+---------------------+--------------------------------------+
| Variable_name       | Value                                |
+---------------------+--------------------------------------+
| slow_query_log      | ON                                   |
| slow_query_log_file | /var/lib/mysql/c27402a5c193-slow.log |
+---------------------+--------------------------------------+
````

- set global slow_query_log = on; //开启慢日志记录

- set long_query_time=0，将慢查询日志的时间阈值设置为 0 //设置慢日志阀值

### 数据库存储结构

[![sD9oRA.md.jpg](https://s3.ax1x.com/2021/01/16/sD9oRA.md.jpg)](https://imgchr.com/i/sD9oRA)

- 区（Extent）是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB=1MB

- 段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64
  个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段

- 表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等

页（Page）如果按类型划分的话，常见的有数据页（保存 B+ 树节点）、系统页、Undo
页和事务数据页等。数据页是我们最常使用的页；在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），InnoDB默认是16K

[![sDCKQ1.md.jpg](https://s3.ax1x.com/2021/01/16/sDCKQ1.md.jpg)](https://imgchr.com/i/sDCKQ1)

- 第一部分: 文件通用部分，也就是文件头和文件尾。它们类似集装箱，将页的内容进行封装，通过文件头和文件尾校验的方式来确保页的传输是完整的；文件头中有两个字段，分别是 FIL_PAGE_PREV 和
  FIL_PAGE_NEXT，它们的作用相当于指针，分别指向上一个数据页和下一个数据页。连接起来的页相当于一个双向的链表

- 第二部分: 记录部分，页的主要作用是存储记录，所以“最小和最大记录”和“用户记录”部分占了页结构的主要空间。另外空闲空间是个灵活的部分，当有新的记录插入时，会从空闲空间中进行分配用于存储新记录

-

第三部分：这部分重点指的是页目录，它起到了记录的索引作用，因为在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索，因此在页目录中提供了二分查找的方式，用来提高记录的检索效率

#### B+ 树的索引的记录检索

如果通过 B+ 树的索引查询行记录，首先是从 B+
树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录

### 脏页(刷脏页导致数据库抖动)

- InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。

- 当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：

1. 如果要淘汰的是一个干净页，就直接释放出来复用；

2. 如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用

#### 控制刷脏页的速度，会参考哪些因素呢？

- innodb_io_capacity 这个参数了，它会告诉 InnoDB 你的磁盘能力

1. 脏页比例;

````
参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%;InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字

InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。
````

2. redo log 写盘速度。

[![yJ0RC8.md.png](https://s3.ax1x.com/2021/02/06/yJ0RC8.md.png)](https://imgchr.com/i/yJ0RC8)