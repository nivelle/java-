### 锁

#### mysql innodb 的行锁是通过锁索引来实现的。

- 如果不通过索引条件来检索数据，那么 InnoDB 将对表中所有的记录加锁，其实就是升级为表锁,然后释放掉不满足的行

#### 锁类型

(1) 共享/排它锁(Shared and Exclusive Locks)

- for update //排他当前读;加的是意向排它记录锁,读到所有已经提交的记录值;如果字段没有索引,即使 使用 where 条件也会进行表级锁

- lock in share mode;//共享当前读,意向共读记录锁

- 对数据进行更新的时候，也就是Insert、delete或者 update的时候，数据库会自动使用排他锁，防止其他事务对该数据进行操作

(2) 意向锁(Intention Locks)

- 给更大一级别的空间示意里面是否已经上过锁。 例如：给数据某行数据上了排他锁，数据库会自动给表加上意向排他锁。

- 如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁

- 事务想要获得数据表中某些记录的排他锁，需要在数据表上添加意向排他锁

```
意向锁之间的互斥关系:

        IS        IX
IS      兼容      兼容
IX      兼容      兼容

--------------------------------

         S       X
IS      兼容      互斥
IX      互斥      互斥

```

(3) 记录锁(Record Locks):针对单个行记录添加锁

(4) 间隙锁(Gap Locks):锁住一个范围，也就是索引之间的空隙。  ( gap lock:innodb_locks_unsafe_for_binlog = disable)

- 间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“幻读”。

- 如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效，此时退化为行锁

- between,>,<以及for update,lock in share mode 造成间隙锁则可能会阻塞update事务

(5)临键锁(Next-key Locks): 帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁+记录锁，可以解决幻读问题

(6)插入意向锁(Insert Intention Locks) 也是一种间隙锁，与间隙锁是互斥的。

(7)自增锁(Auto-inc Locks)

#### 范围划分

(1) 全局锁

- 顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。
  当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句

- unlock tables可以解除

(2) 表级锁

- 表锁

表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables
语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

- MDL（metadata lock）

当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

1. 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。

2. 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行

#### mysql online ddl

1. 拿MDL写锁
2. 降级成MDL读锁
3. 真正做DDL
4. 升级成MDL写锁
5. 释放MDL锁

1、2、4、5如果没有锁冲突，执行时间非常短。第3步占用了DDL绝大部分时间，这期间这个表可以正常读写数据，是因此称为“online ”

#### 安全的给热点表加字段

这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者
DBA 再通过重试命令重复这个过程。

### 数据库行锁

#### 两阶段锁协议

- 在InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是等到事务结束时才释放

### 锁之间兼容矩阵

![锁兼容矩阵.jpg](https://i.loli.net/2020/04/09/3Fvs2N6WiRaOBHl.jpg)

```
自增锁是一种特殊的表级别锁（table-level lock),专门针对事务插入AUTO_INCREMENT类型的列。

最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。

```

#### MySQL 里面表级别的锁有两种：

(1) 表锁

````
表锁的语法是 lock tables … read/write

如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表

````

(2)元数据锁（meta data lock，MDL)

```
MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。

```

- 当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

#### 可重复读情况下才有间隙锁,你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。

**更新或查询一个范围内主键，如果不存在则会加存在的主键的间隙锁，此时另外一个事务插入则会阻塞;如果存在则会退化为行锁,此时另外一个事务插入则不会被阻塞了。**

### 默认隔离级别下的加锁规则

#### 可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。

- 原则 1：加锁的基本单位是 next-key lock是一种前开后闭区间(加锁的对象是: 对索引项以其之间的间隙加锁)

````
1. 加锁的基本单位是next-key lock next-key lock=间隙锁+行锁 前开后闭区间 只有访问过的索引才会加锁 
2. 等值查询： 唯一索引情况下，next-key lock退化成行锁，但是还会继续扫描到最后一个不满足条件的索引为止； 如果是普通索引：next-key lock退化成间隙锁

````

- 原则 2：查找过程中访问到的对象才会加锁

````
1. 如果访问的是普通索引，而且通过索引覆盖并不需要回表查主键索引，那么主键索引上是没有加任何锁的，因为并没有访问主键索引树上的“对象”。

2. 对于未命中索引的查询要走全表扫描，这种在扫描前就会给全表加上next-key lock

3. 访问到的都要加锁，而不是只加锁符合条件的

4. 过程是先访问，访问到再加锁或者访问到最后一个不满足条件的才加锁。

````

- 优化 1：索引上的等值查询,给唯一索引加锁的时候，next-key lock 退化为行锁。

- 优化 2：索引上的等值查询,向后遍历【按索引排序方向】如果发现需要检查的最后一个索引值【最后是指第一个不满足，毕竟之后都不满足了】都不满足等值条件的时候，next-key lock 退化为间隙锁，行锁取消。

````
1. 当查询语句存在降序排序的时候,索引的整体扫描是从右向左即索引键从大到小进行的;但对于范围查询的等值部分仍然是向右遍历的

2. 索引上的等值查询，向后遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁

3. 间隙锁只会对插入操作做限制，对行的修改不不会阻塞

````

- 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

### 案例分析

````

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);

````

#### 案例1： 唯一索引等值查询间隙锁

[![s2jEV0.md.png](https://s3.ax1x.com/2021/01/19/s2jEV0.md.png)](https://imgchr.com/i/s2jEV0)

- id = 7 记录不存在,唯一索引不命中,根据原则1,加锁的单位是 next-lock, session A 的加锁范围是(5,10]

- 优化2：查询条件id=7，向右遍历，第一个不满足条件的记录是(10,10,10)，所以10这条记录退化为间隙锁（行锁没了），next-key lock锁的范围变为(5,10) 结果：sessionB插入数据(8,8,8)在(5,10)
  区间内，等待sessionA锁释放；sessionC id=10行锁解除，只有间隙锁，可以直接更新

#### 案例2：非唯一索引等值锁

[![sREE60.md.png](https://s3.ax1x.com/2021/01/19/sREE60.md.png)](https://imgchr.com/i/sREE60)

- 根据原则1，加锁的单位是next-key lock,因此会给索引c （0，5] 加上next-key lock

- 要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10]加 next-key lock

- 根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。

- 这个Session会有两个锁，一个(0,5]的next-key lock，还有一个是(5,10)的间隙锁

````
问题1：这里为什么不说是sessionA的(0,10)这个区间呢？可以说(0,10)，但是说(5,10)更加精确。 

问题2：这里是第几个7才导致不能插入的？(7,7,7)，是第几个7被阻碍了?第二个7，是c列有锁导致的。这里的间隙锁是增加在索引c列上面的，索引是索引列的值c=7导致插入失败的。
 
问题3：(0,5)是不是也会被锁住？比如插入(3,3,3)这样的一行数据？这个也会被阻塞。 

问题4：为什么(7,0,7)不可以插入，但是(7,10,7)却可以插入？间隙锁(0,10)会把边界0也给锁上吗？如果是，那么为什么有边界10没有锁上？ 用5.7.29的版本，
因为c(0, 10)被锁后，如果插入id=7， c=0 的列，因为c列是非唯一索引，所以会在已经有的 id=0，c=0 的后面增加一个索引记录，id=7，c=0 此时id=7就是c(0, 10)这个位置了。所以被阻塞，此时的id只能是小于0的值，才可以插入成功。比如：c=0, id=-1就可以插入成功，只要是id>0，就会失败。
同样的道理，在c=10的时候，id的值只能是大于10才可以被插入成，如果是小于10就不会插入成功。
````

##### lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。

- 数据行加读锁，如果查询字段使用了覆盖索引，访问到的对象只有普通索引，并没有访问到主键索引，则不会锁主键索引。如果没有使用覆盖索引，且当前查询是for update ,update 和 delete
  都是当前读，则会回表查询，访问到主键索引，这样主键索引也会加锁。

- 锁是加在索引上的；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成
  select d from t where c=5 lock in share mode。

#### 案例3： 主键索引范围锁

[![sRmGPe.md.png](https://s3.ax1x.com/2021/01/20/sRmGPe.md.png)](https://imgchr.com/i/sRmGPe)

- 开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁

- 范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。

- id=10，由于是主键索引，于是next-key lock会给id=10加上行锁，接着id>10and id<11，由于没有符合条件的值，于是nextkey lock会优化成间隙锁 但是为什么会把15也锁住呢？ 修改：id>
  =10会锁住id=10加上next-key lock，（10，15】因为id大于10和id小于11是范围查询不是等值查询，所以仍然会加next-keylock

- 所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。这样，session B 和 session C 的结果你就能理解了。

- 首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断

#### 案例4：非唯一索引范围锁

[![sRnQQs.md.png](https://s3.ax1x.com/2021/01/20/sRnQQs.md.png)](https://imgchr.com/i/sRnQQs)

- 在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10]这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (
  5,10] 和 (10,15] 这两个 next-key lock。

- 在c 向右遍历的时候，发现需要检查的最后一个索引值10，满足条件，所以会锁住10，不会退化成间隙锁

#### 案例5： 低版本bug

[![sRnImt.md.png](https://s3.ax1x.com/2021/01/20/sRnImt.md.png)](https://imgchr.com/i/sRnImt)

- session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15]这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。但是实现上，InnoDB
  会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20]这个 next-key lock 也会被锁上。

#### 案例6：非唯一索引上存在"等值"的例子

[![sRnHk8.md.png](https://s3.ax1x.com/2021/01/20/sRnHk8.md.png)](https://imgchr.com/i/sRnHk8)

- 这时，session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。


- 然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁

#### 案例7： limit 语句加

[![sRu31H.md.png](https://s3.ax1x.com/2021/01/20/sRu31H.md.png)](https://imgchr.com/i/sRu31H)

- delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。

#### 案例8 ：死锁

[![sRu4CF.md.png](https://s3.ax1x.com/2021/01/20/sRu4CF.md.png)](https://imgchr.com/i/sRu4CF)

- session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；

- session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；

- 然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。

- session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。

- 我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。

- 加间隙锁之间是没有冲突的，所以这里间隙锁是加上了的，但是行锁是互斥的

#### 案例9： order by 对锁的影响

[![sRKe2Q.md.png](https://s3.ax1x.com/2021/01/20/sRKe2Q.md.png)](https://imgchr.com/i/sRKe2Q)

- 由于是 order by c desc，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]。

  先加上 （15，20] next-key lock, 由于是索引等值查询，所以继续往右，next-key lock 变为 （15，25], 由于 最右边的值不相同，所以 20，25 部分退化为 间隙锁

- 索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]，这正是阻塞 session B 的 insert 语句的原因。

- 在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 select *，所以会在主键 id 上加三个行锁。 session A 的 select 语句锁的范围就是： 索引 c 上 (5, 25)；主键索引上
  id=15、20 两个行锁

- 扫描规则和加锁规则是不一样的，分开的,扫描到的索引对象要根据规则加上间隙锁。

- next-key lock 是左开右闭，一个索引的落在了右闭上 即为这个索引的next-key lock，这个和查询顺序无关。 所以c>=15 and c <=20 order by c desc
  从右向左，扫描到c=10才停止，c=10的next-key lock为(5,10] 故c上加锁(5,25) 如果去除order by c desc即从左向右，扫描到c=25才停止，c=25的next-key lock为(20,25]
  故c上加锁(10,25] 而不是(10，+∞)

### 在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交

### 死锁问题

#### 死锁的定义

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

[![s4bwKH.md.jpg](https://s3.ax1x.com/2021/01/21/s4bwKH.md.jpg)](https://imgchr.com/i/s4bwKH)

#### 查看死锁

```
use information_schema;

select * from innodb_lock_waits;

select * from innodb_locks;

```

#### 死锁解决

- 执行一下 show processlist 命令，看看当前语句处于什么状态

````
show processlist;
+----+-----------------+-----------+---------+------------+-------+-------------------------+-----------------------------+
| Id | User            | Host      | db      | Command    | Time  | State                   | Info                        |
+----+-----------------+-----------+---------+------------+-------+-------------------------+-----------------------------+
|  5 | event_scheduler | localhost | NULL    | Daemon     | 66675 | Waiting on empty queue  | NULL                        |
| 17 | root            | localhost | test_db | Query      |   240 | User sleep              | select sleep(1) from t      |
| 18 | root            | localhost | test_db | Query      |   230 | Waiting for table flush | flush tables t              |
| 19 | root            | localhost | test_db | Query      |   221 | Waiting for table flush | select * from t where id =1 |
| 20 | root            | localhost | test_db | Field List |    98 | Waiting for table flush |                             |
| 21 | root            | localhost | NULL    | Query      |     0 | init                    | show processlist            |
+----+-----------------+-----------+---------+------------+-------+-------------------------+-----------------------------+

````

- 通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的 process id

##### 比较条件： 互斥，占有且等待，不可强占，循环等待

- 直接进入等待，直到超时。这个超时时间可以通过参数 **innodb_lock_wait_timeout** 来设置，默认超时时间是50s

- mysql 默认开启了死锁检测机制，发现死锁后，主动回滚死锁链条中锁定资源最少的一个事务，让其他事务得以继续执行。 将参数 **innodb_deadlock_detect** 设置为 on，表示开启这个逻辑。(**
  加锁访问的行上有锁，他才要检测**)

- 聚蔟索引更新和二级索引更新，如果是更新同一个索引值也可能引起死锁。

````
select where xxx=123 for update; xxx没有索引

rc 下先锁所有行，再释放掉不符合条件的行锁。 innodb底层其实没有表锁的概念，都是行锁和gap锁。

rr下会全记录和Gap都锁，效果等同于锁表。
````

----
### 乐观锁和悲观锁

[![sBFAHK.md.png](https://s3.ax1x.com/2021/01/15/sBFAHK.md.png)](https://imgchr.com/i/sBFAHK)

1. 乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作

2. 悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读 - 写和写 - 写的冲突。

----

### 自增主键不连续的原因

- 唯一索引冲突，自增主键不回退

- 事务回滚

- insert ...select 批量申请主键ID

#### 自增锁的优化

- 自增ID锁不是一个事务锁，每次申请完就马上释放

