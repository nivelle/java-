### 锁

#### 四种隔离级别

- 读未提交: 事务A读取数据时，事务B读取数据加了共享锁，修改数据时加了排他锁。 会导致脏读，不可重复读以及幻读

- 读提交: 事务A读取数据是加了共享锁，一旦读取，立即释放，事务B读取修改数据是加了行级排他锁，直到事务结束才释放锁。也就是说，事务A在读取数据时，事务B只能读取数据但是不能修改。当事务A读取数据后，事务B才能修改。可以避免脏读，依然存在不可重复读以及幻读的问题。

- 可重复读: 事务A读取数据是加了共享锁，事务结束才释放锁，事务B读取修改数据时加了行级排他锁，直到事务结束才释放锁。也就是说，事务A在没有结束事务时，事务B只能读取数据，不能修改。当事务A结束事务，事务B才能修改。这种隔离级别，可以避免脏读、不可重复读，但依然存在幻读问题。

- 可序列化: 事务A读取事务时加了共享锁，事务结束才释放锁。事务B读取数据修改数据时，加了表级别排他锁，直到事务结束才释放锁。

#### mysql innodb 的行锁是通过锁索引来实现的。

- 如果不通过索引条件来检索数据，那么 InnoDB 将对表中所有的记录加锁，其实就是升级为表锁,然后释放掉不满足的行

#### 锁类型

(1) 共享/排它锁(Shared and Exclusive Locks)

- for update //排他当前读;加的是意向排它记录锁,读到所有已经提交的记录值;如果字段没有索引,即使 使用 where 条件也会进行表级锁
    
- lock in share mode;//共享当前读,意向共读记录锁

- 对数据进行更新的时候，也就是Insert、delete或者 update的时候，数据库会自动使用排他锁，防止其他事务对该数据进行操作

(2) 意向锁(Intention Locks)

- 给更大一级别的空间示意里面是否已经上过锁。 例如：给数据某行数据上了排他锁，数据库会自动给表加上意向排他锁。

- 如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁
  
- 事务想要获得数据表中某些记录的排他锁，需要在数据表上添加意向排他锁

```
意向锁之间的互斥关系:

        IS        IX
IS      兼容      兼容
IX      兼容      兼容

--------------------------------

         S       X
IS      兼容      互斥
IX      互斥      互斥

```

(3)记录锁(Record Locks):针对单个行记录添加锁

(4)间隙锁(Gap Locks):锁住一个范围，也就是索引之间的空隙。  ( gap lock:innodb_locks_unsafe_for_binlog = disable)

- 间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“幻读”。

- 如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效，此时退化为行锁

- between,>,<以及for update,lock in share mode 造成间隙锁则可能会阻塞update事务

(5)临键锁(Next-key Locks): 帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁+记录锁，可以解决幻读问题

(6)插入意向锁(Insert Intention Locks) 也是一种间隙锁，与间隙锁是互斥的。

(7)自增锁(Auto-inc Locks)


### 锁之间兼容矩阵

![锁兼容矩阵.jpg](https://i.loli.net/2020/04/09/3Fvs2N6WiRaOBHl.jpg)

```
自增锁是一种特殊的表级别锁（table-level lock),专门针对事务插入AUTO_INCREMENT类型的列。

最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。

```

#### MySQL 里面表级别的锁有两种：

(1) 表锁

````
表锁的语法是 lock tables … read/write

如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表

````

(2)元数据锁（meta data lock，MDL)

```
MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。

```

- 当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

#### 可重复读情况下才有间隙锁,你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。

- 原则 1：加锁的基本单位是 next-key lock是一种前开后闭区间(对索引项以其之间的间隙加锁)

**更新或查询一个范围内主键，如果不存在则会加存在的主键的间隙锁，此时另外一个事务插入则会阻塞;
如果存在则会退化为行锁,此时另外一个事务插入则不会被阻塞了。**

- 原则 2：查找过程中访问到的对象才会加锁。

- 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。

- 优化 2：索引上的等值查询，向后遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

- 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

- 只在可重复读以上隔离级别下的特定操作才会取得gap lock,next-key lock;

- 在select ,update,delete时除了基于唯一索引的查询之外,其他索引查询时会获取gap lock 或 next-key lock,及锁住其扫描范围，主键索引是不会使用间隙锁的;


### 死锁问题

#### 查看死锁

```
use information_schema;

select * from innodb_lock_waits;

select * from innodb_locks;

```

#### 死锁解决

比较条件： 互斥，占有且等待，不可强占，循环等待

- 直接进入等待，直到超时。这个超时时间可以通过参数 **innodb_lock_wait_timeout** 来设置

- mysql 默认开启了死锁检测机制，发现死锁后，主动回滚死锁链条中锁定资源最少的一个事务，让其他事务得以继续执行。将参数 **innodb_deadlock_detect** 设置为 on，表示开启这个逻辑。(**加锁访问的行上有锁，他才要检测**)

- 聚蔟索引更新和二级索引更新，如果是更新同一个索引值也可能引起死锁。

````
select where xxx=123 for update; xxx没有索引

rc 下先锁所有行，再释放掉不符合条件的行锁。 innodb底层其实没有表锁的概念，都是行锁和gap锁。

rr下会全记录和Gap都锁，效果等同于锁表。
````

### 事务

```
- start transaction;

- 添加事务的SQL语句

- commit or rollback;

```

#### 隔离级别

- 在 MySQL 中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，但不能解决幻读问题

- 当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View

- 在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT 查询都会获取一次 Read View

- RC和RR事务隔离级别是基于多版本并发控制实现高性能事务。一旦数据加上排他锁，其他事务无法加入共享锁，且处于阻塞等待状态。

- MVCC对普通select不加锁,如果读取的数据正在执行delete或则update，这时读取操作不会等待排他锁释放，而是利用 MVCC 读取该数据的快照（数据快照是基于undoLog实现的）

#### 幻读

- 产生幻读的原因是:行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是next_lock。
  跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系
  
- 在读已提交的情况下，InnoDB 只采用记录锁（Record Locking）,因此会出现幻读的情况
  
- 在可重复读隔离级别下, 普通的查询是快照读, 是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。

- 幻读仅仅指的是插入行,修改行不算幻读;


#### 优化原则

- 尽可能使用低级别事务隔离

- 避免行锁升级到表锁

- 控制事务大小，减少锁定的资源量和锁定时间长度（小事务，懒事务）

- 尽量使用主键更新

- 设置锁等待超时等待参数

### 乐观锁和悲观锁

[![sBFAHK.md.png](https://s3.ax1x.com/2021/01/15/sBFAHK.md.png)](https://imgchr.com/i/sBFAHK)

1. 乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作

2. 悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读 - 写和写 - 写的冲突。

### MVCC 多版本并发控制

1. 读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力

2. 降低了死锁的概率。这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行

3. 解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果

#### 快照读

不加锁的简单的select都属于快照读

#### 当前读

当前读就是读取最新数据，而不是历史版本的数据。加锁的 Select 或者对数据进行增删改都会进行当前读

#### 多版本内涵

- 事务版本号：
  每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。
  
- 行记录的隐藏列
  1. db_row_id：隐藏的行 ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率 
  2. db_trx_id：操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID
  3. db_roll_ptr：回滚指针，也就是指向这个记录的 Undo Log 信
    
#### readView 的工作原理

Read View 保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度你可以理解为 Read View 保存了不应该让这个事务看到的其他的事务 ID 列表

1. trx_ids:系统当前正在活跃的事务ID集合
2. low_limit_id:活跃的事务中最大的事务ID
3. up_limit_id:活跃的事务中最小的事务ID
4. creator_trx_id:创建这个Read View 的事务ID

[![sBqpF0.md.png](https://s3.ax1x.com/2021/01/16/sBqpF0.md.png)](https://imgchr.com/i/sBqpF0)

假设当前有事务 creator_trx_id 想要读取某个行记录，这个行记录的事务 ID 为 trx_id

- 如果 trx_id < 活跃的最小事务 ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。

- 如果 trx_id > 活跃的最大事务 ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见

- 如果 up_limit_id < trx_id < low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态，因此我们需要在 trx_ids 集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见。

##### 一个普通读读的流程

1. 首先获取事务自己的版本号，也就是事务 ID；

2. 获取 Read View；

3. 查询得到的数据，然后与 Read View 中的事务版本号进行比较

4. 如果不符合ReadView 规则，就需要从Undo Log 中获取历史快照

5. 最后返回符合规则的数据

MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见

##### MVCC如何解决不可重复读和幻读

在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC 来解决幻读问题。