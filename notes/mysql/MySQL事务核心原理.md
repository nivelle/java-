### 事务

#### 事务的启动

- 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。

- set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback
  语句，或者断开连接。

- 很多语言的第三方库都是使用连接池维持可复用的长连接来保持与mysql的链接，需注意，长连接并不意味着长事务，需要判断是否将autocommit设置成了0.

```
- start transaction;

- 添加事务的SQL语句

- commit or rollback;

```

#### mysql 四种隔离级别

- 读未提交: 一个事务还没提交时，它做的变更就能被别的事务看到。

- 读提交: 一个事务提交之后，它做的变更才会被其他事务看到

- 可重复读: 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的

- 可序列化: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

#### 隔离级别核心概念

- 在 MySQL 中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，但不能解决幻读问题

- 当隔离级别为可重复读的时候,就避免了不可重复读,这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View,而后面所有的 SELECT 都会复用这个 Read View

- 在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT 查询都会获取一次 Read View

- **RC和RR事务隔离级别是基于多版本并发控制(MVCC)底层实现为undoLog来实现高性能事务。**

- MVCC对普通select不加锁,如果读取的数据正在执行delete或则update，这时读取操作不会等待排他锁释放，而是利用 MVCC 读取该数据的快照（数据快照是基于undoLog实现的）

- 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

#### 幻读问题的原因以及解决方法

- 产生幻读的原因是:行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是next_key lock。
  跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系

- 在读已提交的情况下，InnoDB 只采用记录锁（Record Locking）,因此会出现幻读的情况

- 在可重复读隔离级别下, 普通的查询是快照读, 是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。

- 幻读仅仅指的是插入行,修改行不算幻读;

### 长事务问题

- 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

- 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库

### MVCC 多版本并发控制

1. 读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力

2. 降低了死锁的概率。这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行

3. 解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果

#### 快照读

不加锁的简单的select都属于快照读

#### 当前读

- 当前读就是读取最新数据，而不是历史版本的数据。加锁的 Select 或者对数据进行增删改都会进行当前读

- update 更新操作其实分为两个步骤： 当前读，然后更新操作

- select 加上 lock in share mode(S锁，共享锁) 或者 for update (X锁，排他锁)

#### 多版本内涵

- 事务版本号： 每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。

- 行记录的隐藏列
    1. db_row_id：隐藏的行 ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率
    2. db_trx_id：操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID
    3. db_roll_ptr：回滚指针，也就是指向这个记录的 Undo Log 信

#### readView 的工作原理

Read View 保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度你可以理解为 Read View 保存了不应该让这个事务看到的其他的事务 ID 列表

1. trx_ids:系统当前正在活跃的事务ID集合
2. low_limit_id:活跃的事务中最大的事务ID
3. up_limit_id:活跃的事务中最小的事务ID
4. creator_trx_id:创建这个Read View 的事务ID

[![sBqpF0.md.png](https://s3.ax1x.com/2021/01/16/sBqpF0.md.png)](https://imgchr.com/i/sBqpF0)

假设当前有事务 creator_trx_id 想要读取某个行记录，这个行记录的事务 ID 为 trx_id

- 如果 trx_id < 活跃的最小事务 ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。

- 如果 trx_id > 活跃的最大事务 ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见

- 如果 up_limit_id < trx_id < low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态， 因此我们需要在 trx_ids
  集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。 否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见。

##### 一个普通读读的流程

1. 首先获取事务自己的版本号，也就是事务 ID；

2. 获取 Read View；

3. 查询得到的数据【当前值】，然后与 Read View 中的事务版本号进行比较

4. 如果不符合ReadView 规则，就需要从Undo Log 中获取历史快照【想前通过回滚指针找到目标版本】

5. 最后返回符合规则的数据

**MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见**

##### MVCC如何解决不可重复读和幻读

在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC 来解决幻读问题。

#### 优化原则

- 尽可能使用低级别事务隔离

- 避免行锁升级到表锁

- 控制事务大小，减少锁定的资源量和锁定时间长度（小事务，懒事务）

- 尽量使用主键更新

- 设置锁等待超时等待参数

- 如果事务中需要锁多个行,要把最可能造成锁冲突、最可能影响并发读的锁尽量往后放,因为这个锁是在事务提交的时长才释放， 如果一进来就锁住，那么这个事务就很可能成为一个长事务；