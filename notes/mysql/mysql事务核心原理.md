### 事务

```
- start transaction;

- 添加事务的SQL语句

- commit or rollback;

```

#### 隔离级别

- 在 MySQL 中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，但不能解决幻读问题

- 当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View

- 在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT 查询都会获取一次 Read View

- RC和RR事务隔离级别是基于多版本并发控制实现高性能事务。一旦数据加上排他锁，其他事务无法加入共享锁，且处于阻塞等待状态。

- MVCC对普通select不加锁,如果读取的数据正在执行delete或则update，这时读取操作不会等待排他锁释放，而是利用 MVCC 读取该数据的快照（数据快照是基于undoLog实现的）

#### 幻读

- 产生幻读的原因是:行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是next_lock。
  跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系

- 在读已提交的情况下，InnoDB 只采用记录锁（Record Locking）,因此会出现幻读的情况

- 在可重复读隔离级别下, 普通的查询是快照读, 是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。

- 幻读仅仅指的是插入行,修改行不算幻读;


#### 优化原则

- 尽可能使用低级别事务隔离

- 避免行锁升级到表锁

- 控制事务大小，减少锁定的资源量和锁定时间长度（小事务，懒事务）

- 尽量使用主键更新

- 设置锁等待超时等待参数