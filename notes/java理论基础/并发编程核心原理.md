### 并发编程问题的根源

#### 缓存导致可见性问题

- 多核系统存在多级缓存

- 可见性的定义: 一个线程对共享变量的修改，另外一个线程能够立刻看到

#### 线程切换带来的原子性问题

- 高级编程语言的一个操作可能涉及多个cpu指令

- 操作系统做任务切换，可以发生在任何一条cpu指令执行完

- 原子性定义:一个或者多个操作在CPU 执行过程中不被中断

- 原子性的本质: 多个资源间有一致性的要求，操作的中间状态对外不可见

````
count+=1;

1. 把变量从内存加载到CPU寄存器
2. 在寄存器中执行 +1 操作
3. 将结果写入内存

````

#### 编译优化导致的有序性问题

````
public class DoubleCheck {

    static DoubleCheck doubleCheck;

    static DoubleCheck getInstance() {
        if (doubleCheck == null) {
            synchronized (DoubleCheck.class) {
                if (doubleCheck == null) {
                    doubleCheck = new DoubleCheck();
                }
            }
        }
        return doubleCheck;
    }
}

````

##### 双重检查方式构建一个单例对象是，在new 一个实例的过程被编译器优化为以下步骤：

- 分配一块内存M

- 将M 的地址赋值给 instance 变量（若此时发生线程切换）

- 最后在内存 M 上初始化 对象

### Happens-Before 规则

- 前面一个操作的结果对后续操作是可见的。

- Happens-Before 是一种编译规范，编译器实现是按照这个规范实现的，是对编译优化的一种约束，优化后的代码也要遵守该规则

1. 程序顺序性规则: 前面的操作Happens-Before于后续的任意操作

2. volatile变量规则：对一个volatile变量的写操作，Happens-Before于后续对这个volatile变量的读操作

3. 传递性规则:如果 A Happens-Before B，且B Happens-Before C，那么 A Happens-Before C

4. 线程 start() 规则:  如果线程A 调用线程B的start()方法，那么该start()操作Happens-Before 于线程B中的任意操作。

5. 线程join()规则：主线程A 等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join方法返回），主线程能看到子线程的操作。

6. 线程中断规则： 对线程interrupt()方法调用happens-before于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。

### 死锁发生的原因

#### 四个条件都满足的情况下，才会发生死锁

- 互斥，某个共享资源某一时刻只能被一个线程占用

- 占有且等待：线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；

- 不可抢占： 其他线程不能强行抢占线程 T1 占有的资源

- 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

### synchronized 实现等待-通知机制

- 线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。

### 竞态条件

- 指的是程序执行结果以来线程执行的顺序。

- 并发场景中，程序的执行依赖某个状态变量

### 并发编程的目的

- 降低延迟

- 提高吞吐量

- 利用多线程，提高CPU和 I/O 设备的综合利用率；如果仅仅有CPU计算没有I/O 操作的话，多线程并不会提升性能，反而因为线程切换增加了成本

- 多核情况下，多线程也可以用来降低响应成本

### 多线程数目计算

- IO密集型

````
单核: 最佳线程数 =1 +（I/O 耗时 / CPU 耗时）

多核: 最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]
````

- CPU密集型

````
1. 对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。

2. 不过在工程上，线程的数量一般会设置为“CPU 核数 +1”，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。

````

#### 用锁的最佳实践

- 永远只在更新对象的成员变量时加锁

- 永远只在访问可变的成员变量时加锁

- 永远不在调用其他对象的方法时加锁