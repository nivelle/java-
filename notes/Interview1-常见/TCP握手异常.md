当端口不充足的时候，会导致 connect 系统调用的时候过多地执行自旋锁等待与 Hash 查找，会引起 CPU 开销上涨。严重情况下会耗光 CPU，影响用户业务逻辑的执行。出现这种问题处理起来方法有这么几个。
通过调整 ip_local_port_range 来尽量加大端口范围
尽量复用连接，使用长连接来削减频繁的握手处理
第三个有用，但是不太推荐的是开启 tcp_tw_reuse 和 tcp_tw_recycle
服务器端在第一次握手时可能会丢包， 在如下两种情况下会发生。
半连接队列满，且 tcp_syncookies 为 0
全连接队列满，且有未完成的半连接请求
在这两种情况下，客户端视角来看和网络断了没有区别，就是发出去的 SYN 包没有任何反馈，然后等待定时器到时后重传握手请求。第一次重传时间是 1 s ，接下来的等待间隔是翻倍地增长，2 s，4 s，8 s ...。总的重传次数由 net.ipv4.tcp_syn_retries 内核参数影响（注意我的用词是影响，而不是决定）。
服务器在第三次握手时也可能会出问题，如果全连接队列满，仍将会发生丢包。不过第三次握手失败时，只有服务器端知道（客户端误以为连接已经建立成功了）。服务器根据半连接队列里的握手信息发起 synack 重试，重试次数由 net.ipv4.tcp_synack_retries 控制。
一旦你的线上出现了上面这些连接队列溢出导致的问题，你的服务将会受到比较严重的影响。即使第一次重试就能够成功，那你的接口响应耗时将直接上涨到 1 s（老版本上是 3 s）。如果重试上两三次都没有成功，Nginx 很有可能直接就报访问超时失败了。
正因为握手重试对我们服务影响很大，所以能深刻理解三次握手中的这些异常情况很有必要。再说说如果出现了丢包的问题，我们该如何应对。
方法1，打开 syncookie
在现代的 Linux 版本里，我们可以通过打开 tcp_syncookies 来防止过多的请求打满半连接队列包括 SYN Flood 攻击，来解决服务器因为半连接队列满而发生的丢包。
方法2，加大连接队列长度
全连接队列的长度是 min(backlog, net.core.somaxconn)半连接队列长度是。半连接队列长度有点小复杂，是 min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再上取整到 2 的幂次，但最小不能小于16。
如果需要加大全/半连接队列长度，请调节以上的一个或多个参数来达到目的。只要队列长度合适，就能很大程序降低握手异常概率的发生。
方法3，尽快地 accept
另外这个虽然一般不会成为问题，但也要注意一下。你的应用程序应该尽快在握手成功之后通过 accept 把新连接取走。不要忙于处理其它业务逻辑而导致全连接队列塞满了。
方法4，尽量减少 TCP 连接的次数
如果上述方法都未能根治你的问题，那说明你的服务器上 TCP 连接请求太、太过于频繁了。这个时候你应该思考下是否可以用长连接代替短连接，减少过于频繁的三次握手。这个方法不但能解决握手出问题的可能，而且还顺带砍掉了三次握手的各种内存、CPU、时间上的开销，对提升性能也有较大帮助。