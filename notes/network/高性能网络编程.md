### select

#### 标准输入、套接字等看作I/O的一路，多路复用是指：任何一路有"事件"发生的情况下，通知应用程序去处理相应的I/O事件

##### 监听事件

1. 标准输入文件描述符准备好可以读

2. 监听套接字准备好，新的连接已经建立成功

3. 已连接套接字准备好可以写

4. 如果一个I/O 事件等待超过了10秒，发生了超时事件

#### 使用select函数，通知内核挂起进程，当一个或多IO事件发生后，控制权返还给应用程序，由应用程序进行IO事件的处理

1. 检测IO事件发生（阻塞）

2. 进行IO数据读写（同步)）

- 在移除阻塞点同时检测多个来自IO的事件。

````

int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);


````

- 返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1

- maxfd: 表示的是待测试的描述符基数，它的值是待测试的最大描述符加1

- readset：读描述符集合

- writeset: 写描述符集合

- exceptset: 异常描述符集合

- timeout：如果为空，表示如果没有I/O事件发送，则select一直等待；若为非0值，表示等待固定一段时间后从阻塞调用中返回


#### 支持文件描述符个数有1024的限制


-------------------

### poll

````
int poll(struct pollfd *fds,unsigned long nfds,int timeout);

````

- 返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1


#### 突破了文件描述符的个数限制


-----------------

### epoll

- epoll通过改进的接口设计，避免了用户态-内核态频繁数据拷贝，大大提高了系统性能。

- 条件触发的意思是只要满足事件的条件，比如有数据需要读，就一直不断地把这个事件传递给用户；边缘触发的意思是只有第一次满足条件的时候才触发，之后就不再传递同样的事件了。

- epoll返回的是有事件发生的数组，而poll返回的是准备好的个数，每次poll函数返回都要遍历注册的描述符结合数组尤其是数量越大遍历次数就越多。

### 阻塞I/O和进程模型

#### 子进程

- fork 函数： 把当前父进程的所有相关值clone 一份，包括地址空间、打开的文件描述符号、程序计数器、执行代码，新派生的进程的表现行为和父进程一样。区别两个进程：返回值不一样，父进程返回新派生子进程pid ,子进程返回0

- 子进程退出后，保留的信息如果不回收，则会成为僵尸进程，这种进程会挂到进程号为1 的init 进程上；父进程派生出的子进程，也必须由父进程负责回收，否则子进程会成为僵尸进程。

- 处理子进程退出的方式一般是注册一个信号处理函数，获取信号 SIGCHILD,然后再在信号处理函数里调用waitpid函数来完成子进程资源的回收。SIGCHILD是子进程退出或者中断时由内核向父进程发出的信号，默认这个信号是忽略的。

#### 阻塞I/O的进程模型

第一个客户端发起连接请求，连接建立后产生出连接套接字，此时，父进程派生出一个子进程，在子进程中，使用连接套接字和客户端通信，子进程不需要关心监听套接字，只需要关心连接套接字；父进程相反，将客户服务交给子进程来处理，因此父进程不需要关心连接套接字，只需要关心监听套接字。

### 阻塞I/O 和线程模型

- 一旦有新连接建立，阻塞调用并返回，创建一个子线程来处理这个建立的连接逻辑

- 线程频繁创建和销毁开销巨大，通过引入线程池解决

- 服务端启动时，可以先按照固定大小预创建出多个线程，当有新连接建立是，往连接字队列放置这个新连接描述字，线程池里的线程负责从连接字队列里取出连接字描述字进行处理

- 没有解决空闲连接占用资源的问题，如果一个连接在一定时间内没有数据交互，这个连接还要占用一定的线程资源，直到这个连接消亡为止

[![rbkcdS.png](https://s3.ax1x.com/2020/12/29/rbkcdS.png)](https://imgchr.com/i/rbkcdS)

### I/O 多路复用和线程

#### 事件驱动模型：反应堆模型（reactor）或者 Event loop 模型

- 它存在一个无限循环的事件分发线程，或者叫做 reactor 线程、Event loop线程。 事件分发就是pool、epoll等I/O分发技术的使用。

- 所有的I/O 操作都可以抽象成事件，每个事件必须有回调函数来处理。acceptor 上有连接建立成功；已连接套接字上发送缓冲区空出可以写、通信管道pipe上有数据可以读，通过事件分发器，这些事件都可以被检测到，并调用对于的回调函数处理

#### single reactor thread

一个reactor 线程上同时负责分发 acceptor 的事件、已连接套接字的I/O 事件

![single ractor threa模型.png](https://i.loli.net/2020/12/29/R6QO4zLDjZUWnoJ.png)

#### single reactor thread + worker threads

- 和 I/O 事件处理相比，业务处理的耗时比较严重，为了解决这个问题，业务处理交给线程池处理

- 反应堆线程处理I/O 相关工作，业务逻辑相关工作被分割成小任务，放到线程池里区执行，执行完成后再返回给反应堆线程

![singlereactorwokers.png](https://i.loli.net/2020/12/29/WzMmOZ3eig2YUov.png)

#### 主--从 reactor + workers threads 模式

- single reactor 模式reactor既分发已建立连接的I/O 事件，又分发建立连接事件，导致客户端连接成功率降低

- 将acceptor 上的连接建立事件和已建立连接的I/O事件分离

- 这里将 decode、compute、encode 等 CPU 密集型的工作从 I/O 线程中拿走，这些工作交给 worker 线程池来处理，而且这些工作拆分成了一个个子任务进行。encode 之后完成的结果再由 sub-reactor
  的 I/O 线程发送出去

- 主 - 从Reactor模式的核心思想是，主Reactor线程只负责分发 Acceptor 连接建立，已连接套接字上的 I/O 事件交给 从Reactor 负责分发。其中 sub-reactor 的数量，可以根据 CPU
  的核数来灵活设置。

![netty线程工作模型.png](https://i.loli.net/2020/12/29/TjuN9g3M8P6DOEa.png)