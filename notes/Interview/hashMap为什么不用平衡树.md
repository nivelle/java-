### stackoverflow

#### 第一个问题：hashMap 为什么不一直使用树？

内存占用与存储桶内查找复杂性之间的权衡。大多数哈希函数将产生非常少的冲突，因此为大小为3或4的桶维护树将是非常昂贵的，没有充分的理由

#### 第二个问题：为什么hash冲突使用红黑树而不是AVL树

- AVL树更加严格平衡，可以提供更快的查找效果，所以，对于查找密集型任务，使用AVL

- 红黑树通过对任何一条从根到叶子的路径上各个节点着色方式的限制，确保没有一条路径会比其他路径长出两倍， 因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度<=红黑树），
  相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，用红黑树

### 树

- 节点的高度 = 节点到叶子节点的最长路径

- 节点的深度 = 根节点到这个节点所经历的边的个数

- 节点的层数 = 节点的深度+1

- 树的高度 = 根节点的高度

[![sc3mMd.md.jpg](https://s3.ax1x.com/2021/01/18/sc3mMd.md.jpg)](https://imgchr.com/i/sc3mMd)

#### 二叉树

每个节点最多有两个子节点，则成为二叉树

#### 满二叉树

叶子节点都在最低层，除了叶子节点外，每个节点都有左右两个子节点

#### 完全二叉树

叶子节点都在最低的两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大

#### 二叉树的存储

- 链式存储： 链式存储法，每个节点有三个字段，一个存储数据，另外两个存储指向左右子节点的指针。大部分二叉树代码都是通过这种结构来实现的。

- 数组的顺序存储：如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2
  的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。

- 堆其实就是一种完全二叉树，最常用的存储方式就是数组，完全二叉树这种用数组存储方式是最节省内存的

#### 二叉查找树（二叉搜索树）

- 在树中的任意一个节点，其左子树中的每个节点的值都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

- 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度O(n),非常高效

- 二叉查找树中存储的，是一个包含很多字段的对象，我们利用对象的某个字段作为键值（key）来构建二叉查找树，把对象中的其他字段叫做卫星数据。

- 极度不平衡的二叉查找树，退化成列表，时间复杂度O(n);平衡二叉查找树 O(logn)

#### 平衡二叉查找树(AVL树)

- 二叉树中任意一个节点的左右子树的高度差不能大于1。

- 平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化得太严重。

#### 红黑树

- 不严格的平衡二叉查找树

- 从根节点到各个叶子节点的最长路径，有可能比最短路径大一倍

- 红黑树每个路径黑色节点个数相同,也就是最短的路径纯黑色和最长的路径黑红相间相差一倍. 假设只有其他边都是黑色,只有1条是红黑最长. 也就是满二叉树多出了一条2倍高度的边. 满二叉树是lgN. 红黑树是2*lgN.

- 红黑树的高度只比 平衡二叉查找树(AVL树) 的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好

[![sc7UXT.md.jpg](https://s3.ax1x.com/2021/01/19/sc7UXT.md.jpg)](https://imgchr.com/i/sc7UXT)

### 红黑树叶子节点为什么使用双向连表来关联节点

- 叶子节点间使用双向链表链接，满足asc 和des 排序，同时删除和增加效率提高
- 满足区间查找