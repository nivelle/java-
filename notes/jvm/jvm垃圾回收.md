### jvm垃圾回收

#### 查看垃圾回收机器类型: ps 命令查询出进程 ID，再通过 jmap -heap ID 查询出 JVM 的配置信息，其中就包括垃圾收集器的设置类型。

- 引用计数法:额外的空间来存储计数器.解决不了循环引用,造成内存泄露

- 可达性分析:将GCRoots作为初始的存活对象合集，然后从该合集出发，探索所有能够被该集合引用到的兑现，并将其加入到该集合。常见GCRoot如下：

    - java虚拟机栈方法栈桢中的局部变量

    - 已加载类的静态变量

    - JNI handles

    - 已启动且未停止的java线程

**缺点**: 多线程环境下其他线程更新已经访问过的对象中的引用，从而造成误报(将引用设置为null)或者漏报(将引用设置为未被访问过的对象)。

#### stop-the-world 解决漏报问题

- 停止其他非垃圾回收线程，直到完成垃圾回收，但造成了GC pause

- safePoint:当收到stop-the-world请求,它会等待所有的线程达到安全点,才允许请求stop-the-world的线程进行独占工作。（安全点：找到一个稳定的执行状态，在合格状态下java虚拟机的堆栈不会发生变化）

    1. JNI执行本地代码，不访问java对象、调用java方法，

    2. 解释执行字节码

    3. 执行即时编译器生成的机器码时和线程阻塞。阻塞的线程处于java虚拟机线程调度的掌握，属于安全点。

#### 卡表技术

- 将整个堆划分为一个个大小512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果存在认为是脏的。

- 用来解决老年代引用新生代产生的全堆扫描。

#### jvm垃圾回收算法-回收类型

- java引用类型

![引用类型.jpg](https://i.loli.net/2020/04/05/iSM3oLxR1cldZUT.jpg)

- 垃圾回收算法

![垃圾回收算法.jpg](https://i.loli.net/2020/04/05/cnbJiF2W96zy1q4.jpg)

- 常见回收器

![回收器.png](https://i.loli.net/2020/04/05/muYO9ve7sXjSopf.png)

![cms垃圾回收器.jpg](https://i.loli.net/2020/04/06/fFjIY5vcdaKTmVn.jpg)

![回收器及算法配置.jpeg](https://i.loli.net/2020/04/06/g3izXqQ4YhJBf7A.jpg)