### jvm垃圾回收

#### 查看垃圾回收机器类型: ps 命令查询出进程 ID，再通过 jmap -heap ID 查询出 JVM 的配置信息，其中就包括垃圾收集器的设置类型。

- 引用计数法:额外的空间来存储计数器.解决不了循环引用,造成内存泄露

- 可达性分析:将GCRoots作为初始的存活对象合集，然后从该合集出发，探索所有能够被该集合引用到的兑现，并将其加入到该集合。常见GCRoot如下：

    - java虚拟机栈方法栈桢中的局部变量

    - 已加载类的静态变量

    - JNI handles

    - 已启动且未停止的java线程

**缺点**: 多线程环境下其他线程更新已经访问过的对象中的引用，从而造成误报(将引用设置为null)或者漏报(将引用设置为未被访问过的对象)。

#### stop-the-world 解决漏报问题

- 停止其他非垃圾回收线程，直到完成垃圾回收，但造成了GC pause

- safePoint:当收到stop-the-world请求,它会等待所有的线程达到安全点,才允许请求stop-the-world的线程进行独占工作。（安全点：找到一个稳定的执行状态，在合格状态下java虚拟机的堆栈不会发生变化）

    1. JNI执行本地代码，不访问java对象、调用java方法，

    2. 解释执行字节码

    3. 执行即时编译器生成的机器码时和线程阻塞。阻塞的线程处于java虚拟机线程调度的掌握，属于安全点。

-----

#### jvm垃圾回收算法-回收类型

- java引用类型

![引用类型.jpg](https://i.loli.net/2020/04/05/iSM3oLxR1cldZUT.jpg)

- 垃圾回收算法

![垃圾回收算法.jpg](https://i.loli.net/2020/04/05/cnbJiF2W96zy1q4.jpg)

- 常见回收器

![回收器.png](https://i.loli.net/2020/04/05/muYO9ve7sXjSopf.png)

- CMS垃圾回收器回收过程

![cms垃圾回收器.jpg](https://i.loli.net/2020/04/06/fFjIY5vcdaKTmVn.jpg)

- 常见回收器类型及其回收算法

![回收器及算法配置.jpeg](https://i.loli.net/2020/04/06/g3izXqQ4YhJBf7A.jpg)

--------

- 针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是标记 - 复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial
  的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。

- 针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是标记 -
  压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。

- G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记 -
  压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。

#### java虚拟机堆的划分

- 默认情况下，Java 虚拟机采取的是一种动态分配的策略（对应 Java 虚拟机参数 **-XX:+UsePSAdaptiveSurvivorSizePolicy**），根据生成对象的速率，以及 Survivor 区的使用情况动态调整
  Eden 区和 Survivor 区的比例。

- 也可以通过参数 -XX:SurvivorRatio 来固定这个比例。但是需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高

- 堆空间是线程共享的，直接在里面划分空间需要进行同步，java虚拟机使用的是TLAB(Thread Local Allocation Buffer，对应虚拟机参数 **-XX:+UseTLAB**，默认开启)

- 每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB

````

1. 这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。

2. 接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数

3. 如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。

````

#### minor GC

- Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 **-XX:+MaxTenuringThreshold**），那么该对象将被晋升（promote）至老年代

- 如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 **-XX:TargetSurvivorRatio**），那么较高复制次数的对象也会被晋升至老年代。

---

- 发生 Minor GC 时，我们应用了标记 - 复制算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden
  区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好

- Minor GC
  的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC
  Roots;为了避免这个问题，引入了卡表技术

#### 卡表技术

- 将整个堆划分为一个个大小512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果存在认为是脏的。

- 用来解决老年代引用新生代产生的全堆扫描。

````
在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零

````

- HotSpot 引入了一个新的参数 **-XX:+UseCondCardMark**，来尽量减少写卡表的操作，避免虚共享