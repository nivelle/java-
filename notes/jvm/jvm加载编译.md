### JVM

#### java虚拟机-> 路径: Path,ClassPath,JAVA_HOME

#### JAVA_HOME

- 方便引用，配置path时，就是通过引用JAVA_HOME路径来实现的，这样避免了写很长一串的路径（比如在我的电脑中，path原路径是”C:\Program
  Files\Java\jdk1.8.0_131\bin”，通过指定JAVA_HOME，现在设定的path路径变成了”%JAVA_HOME%\bin”，更加简洁）

- 更加安全，当JDK改变时，仅需要改变JAVA_HOME的路径即可，path和CLASSPATH由于引用了JAVA_HOME，其所对应的路径也会更改。如果不引用JAVA_HOME，则JDK路径改变时，需要手动去设定PATH和CLASSPATH的路径，一旦路径错误，则程序会崩溃。

- 第三方软件（如tomcat，eclipse）都是引用约定好的JAVA_HOME变量，如果不指定JAVA_HOME，则将无法使用第三方软件。

#### path

- 配置Path是为了在任意目录下都能使用java、javac命令。

#### classPath

- 配置CLASSPATH是为了引入一些已经写好的类。

- 我们一般这样设置：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;

- 前面的“.”不可少，它代表了我们为自己的java类建立的工作路径，其它的是jdk自带的标准类库路径。

------

### java指令编译运行以及反汇编

- 反编译：将 .class 文件逆向成 java源代码

- 反汇编：根据编译后的结果，倒推源码编译的过程，这里就可以看出代码逻辑真实编译、执行过程的每一步，对于性能优化、问题追溯等具有十分强大的帮助

- javac;//编译

```
cd /Users/nivellefu/IdeaProjects/javadaybyday/java-base/src/main/java/com/nivelle/base/pojo/javaclass;javac -d . /Users/nivellefu/IdeaProjects/javadaybyday/java-base/src/main/java/com/nivelle/base/pojo/javaclass/JvmExceptionDemo.java
```

- java;//运行

```
java class文件指定的page路径+类名

```

- javap -v -p //根据classs字节码文件，反解析出当前类对应的code区（汇编指令），本地变量表，异常表和代码偏移量映射表，常量池等信息。

```
这里面我用到了两个选项。第一个选项是 -p。默认情况下 javap 会打印所有非私有的字段和方法，当加了 -p 选项后，它还将打印私有的字段和方法。第二个选项是 -v。它尽可能地打印所有信息。如果你只需要查阅方法对应的字节码，那么可以用 -c 选项来替换 -v。

 
```

----------------------

### 编译加载

![类加载编译过程.jpg](https://i.loli.net/2020/04/05/h3jRw2eDUY1dkB5.jpg)

- 编译后的字节码文件主要包括常量池和方法表集合这两部分

1. 常量池主要记录的是类文件中出现的字面量以及符号引用。字面常量包括字符串常量（例如 String str=“abc”，其中"abc"就是常量），声明为 final 的属性以及一些基本类型（例如，范围在 -127-128
   之间的整型）的属性。 符号引用包括类和接口的全限定名、类引用、方法引用以及成员变量引用（例如 String str=“abc”，其中 str 就是成员变量引用）等。

2. 方法表集合中主要包含一些方法的字节码、方法访问权限（public、protect、private 等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM 执行指令以及属性集合等。

### 类的加载

- 除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载

- 拓展类加载器，引用类加载器、自定义类加载器是java.lang.ClassLoader的子类实例，自定义类加载器直接继承java.lang.classLoader

#### 类加载,是指查找字节流,并且据此创建类的过程；查找并加载类的二进制数据到java虚拟机中

- Bootstrap 启动类加载器:JDK\jre\lib 目录下 jar包中的类或者由虚拟机参数 **-Xbootclasspath** 指定的类, 比如 rt.jar、charsets.jar;同时所有的java.开头的类

启动类加载器是无法被java程序直接引用的。启动类加载器加载java运行过程中的核心类库：

````
1. JRE\lib\rt.jar
2. sunrsasign.jar
3. charsets.jar
4. jce.jar
5. jsse.jar
6. plugin.jar
7. 存放在JRE\classess里面的类，也就是JDK提供的类比如常见的: Object、String、List
````

- Extension扩展类加载器:JDK\jre\lib\ext 目录下 jar 包中的类或者由系统变量 **java.ext.dirs**指定的类,比如
  dnsns.jar、zipfs.jar;以javax.开头的类，开发者可以直接使用拓展类加载器

````
Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。
````

- Application应用类加载器:它负责加载应用程序路径下的类 -cp也就是-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径

##### JVM 会先加载 class 文件，而在 class 文件中除了有类的版本、字段、方法和接口等描述信息外,还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种字面量和符号引用

**(类加载进内存后，JVM就会将class文件常量池中的内容存放到运行时常量池中也就是方法区中)**

1. 字面量:字符串,基本类型的常量

2. 符号引用: 类和方法的全限定名

#### 双亲委派机制

- 避免类的重复加载:当父加载器已经加载了该类的时候,就没必要子ClassLoader再加载一次,保证被加载类的唯一性

- 沙箱子安全机制: 自己写的java.lang.String.class 类不会被加载，这样防止核心API库被随意串改

#### 类加载器的名字空间作用

````
在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。
````

-----------------

### 类的链接

**是指将创建成的类合并至 Java 虚拟机中,使之能够执行的过程**

- 第一步验证:文件合法性检查

- 第二步准备:

(1). **被加载类的静态字段分配内存**

(2). 对于 **final static** 修饰的变量,直接赋值为用户的定义值。

(3). 构造其他跟类层次相关的数据结构，比如用来实现虚方法的动态绑定的方法表

 ````
 例如:private final static int value=123,会在准备阶段分配内存,并初始化值为 123,
 
 而如果是 private static int value=123，这个准备阶段 value 的值仍然为 0。 
 ````

- 第三步解析：

````
Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

````

(1).符号引用->实际引用;

````
在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

符号引用:编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用来指代所要调用的方法;
````

(2).形成对常量池字符串的索引值;

(3).如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化）

### 类的初始化

- **为类的静态变量赋予正确的初始值**，在准备阶段仅仅是分配了内存，提供的是默认值

##### 为标记为常量值的字段赋值,以及执行 <clinit> 方法的过程。类的初始化仅会被执行一次,这个特性被用来实现单例的延迟初始化。

- 如果要初始化一个静态字段,我们可以在声明时直接赋值,也可以在静态代码块中对其赋值

- **如果直接赋值的静态字段被 final 所修饰,并且它的类型是基本类型或字符串时,那么该字段便会被 Java 编译器标记成常量值(ConstantValue)其初始化直接由 Java
  虚拟机完成。除此之外的直接赋值操作,以及所有静态代码块中的代码,则会被 Java 编译器置于同一方法中,并把它命名为 <clinit>。**

- Java 虚拟机会通过加锁来确保类的 <clinit> 方法仅被执行一次

##### java类的初始化触发

(1). 当虚拟机启动时,初始化用户指定的主类;

(2). 当遇到用以**新建目标类**实例的 new 指令时,初始化 new 指令的目标类；

(3). 当遇到调用**静态方法**的指令时,初始化该静态方法所在的类;

(4). 当遇到访问**静态字段**的指令时,初始化该静态字段所在的类;

(5). 子类的初始化会触发父类的初始化;

(6). 如果一个接口定义了 default 方法,那么直接实现或者间接实现该接口的类的初始化,会触发该接口的初始化;

(7). 使用反射 API 对某个类进行反射调用时,初始化这个类；

(8). 当初次调用 MethodHandle 实例时,初始化该 MethodHandle 指向的方法所在的类。


------------

### 解释器执行与即时编译

在 HotSpot 里面,将字节码翻译为机器码有两种方式，第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译(just-in-time compilation,JIT),即将一个方法中包含的所有字节码编译成机器码后再执行

#### 解释器模式(interpreter)

- 一条一条地读取,解释并且执行字节码指令。因为它一条一条地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢，没有JIT的配合下效率不高

- 指定“-Xint”，就是告诉 JVM 只进行解释执行，不对代码进行编译，这种模式抛弃了 JIT 可能带来的性能优势

- “-Xcomp”参数，这是告诉 JVM 关闭解释器，不要进行解释执行，或者叫作最大优化级别

#### 动态编译模式(Just-In-Time):

- 即时编译器把整段字节码不加筛选的编译成机器码不论其执行频率是否有编译价值，在程序响应时间的限制下，没有达到最大的优化。

- C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。

- C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。

- Java 8 默认开启了分层编译。

  (1). 第 0 层：程序解释执行,默认开启性能监控功能（Profiling）,如果不开启,可触发第二层编译;

  (2). 第 1 层: 可称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启 Profiling；

  (3). 第 2 层：也称为 C1 编译,开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译；

  (4). 第 3 层：也称为 C1 编译,执行所有带 Profiling 的 C1 编译；

  (5). 第 4 层：可称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

##### 即时编译的触发

Java 虚拟机是根据方法的调用次数以及循环回边的执行次数来触发即时编译的。前面提到，Java 虚拟机在 0 层、2 层和 3 层执行状态时进行 profiling，其中就包含方法的调用次数和循环回边的执行次数。

#### 热点探测

##### 方法调用计数器

- **XX:TieredStopAtLevel = 1** 仅仅使用C1编译 在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的和，超过由参数 **-XX:CompileThreshold** 指定的阈值时（使用 C1
  时，该值为 1500；使用 C2 时，该值为 10000），便会触发即时编译

##### 启用分层编译时，Java 虚拟机将不再采用由参数 -XX:CompileThreshold 指定的阈值（该参数失效），阈值的大小是动态调整的，Java 虚拟机会将阈值与某个系数 s 相乘。该系数与当前待编译的方法数目成正相关，与编译线程的数目成负相关

- XX:-TieredCompilation 关闭分层编译

- Xint: 强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作

- Xcomp:强制虚拟机运行于只有 JIT 的编译模式下

##### 回变计数器

用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge);

- 该值用于计算是否触发 C1 编译的阈值，在不开启分层编译的情况下，C1 默认为 13995，C2 默认为 10700，

- 通过 **-XX: OnStackReplacePercentage=N** 来设置；

而在分层编译的情况下，-XX: OnStackReplacePercentage 指定的阈值同样会失效，此时将根据当前待编译的方法数以及编译线程数来动态调整。建立回边计数器的主要目的是为了触发 OSR（On
StackReplacement）编译，即栈上编译，将编译后的机器语言缓存。

### jvm 方法调用

- 重写: 多态最重要的一种体现方，它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

- 重载: 名字相同,参数类型不同的方法;重载也可以作用于这个类所继承而来的方法；

```
重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；

2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；

3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

```

- Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说， 由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

```

在编译完成之后，我们可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。

当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在Java编译器的用户类路径上时，当前版本的Java编译器会直接选取第一个方法名以及参数类型匹配的方法。

并且，它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。

```

- Java 虚拟机的动态绑定是通过**方法表**这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。

- Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。

--------

### 反射调用的实现

````
 public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException,InvocationTargetException
    {
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class<?> caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, obj, modifiers);
            }
        }
        //MethodAccessor 是一个接口，它有两个已有的具体实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式。
        MethodAccessor ma = methodAccessor; // read volatile
        if (ma == null) {
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args);
    }
````

- 每个 Method 实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现

- Java 的反射调用机制还设立了另一种动态生成字节码的实现,直接使用invoke指令来调用目标方法;之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。

- 动态实现比本地实现，效率上要快20倍，因为动态实现无需经过java到C++再到Java的切换，但由于生成字节码十分耗时，仅调用一次，反而是本地实现要快3到4倍

- Java 虚拟机设置了一个阈值 15（可以通过 **-Dsun.reflect.inflationThreshold**= 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15
  时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation[膨胀]。

#### 反射调用的开销

- Class.forName 会调用本地方法, Class.getMethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。

- 以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗

- 由于Method.invoke 第二个参数是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组;由于Object数组不能存储基本类型,Java 编译器会对传入的基本类型参数进行自动装箱

**以上两个操作除了带来性能开销外,还可能占用堆内存,使得 GC 更加频繁。**

##### 方法内联:方法内联指的是编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法调用这么个过程

````
内联函数就是指函数在被调用的地方直接展开，编译器在调用时不用像一般函数那样，参数压栈，返回时参数出栈以及资源释放等，这样提高了程序执行速度。
Java不支持直接声明为内联函数的，如果想让他内联，则是由编译器说了算，你只能够向编译器提出请求。
````

---------

### invokedynamic

1. java7 引入的一条新指令，支持动态语言的方法调用
2. 将调用点抽象成java类，并且将原本由java虚拟机控制的方法调用以及方法链暴露给应用程序；每一条invokedynamic指令捆绑一个调用点，并且会调用该调用点所链接的方法句柄
3. Lambda 表达式到函数式接口的转换是通过 invokedynamic 指令来实现的。该 invokedynamic 指令对应的启动方法将通过 ASM 生成一个适配器类

```
对于没有捕获其他变量的 Lambda 表达式，该 invokedynamic 指令始终返回同一个适配器类的实例。对于捕获了其他变量的 Lambda 表达式，每次执行 invokedynamic 指令将新建一个适配器类实例
```

### 编译优化

#### 方法内联

方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。

- 经常执行的方法，默认情况下，方法体大小小于 325 字节的都会进行内联，我们可以通过 -XX:MaxFreqInlineSize=N 来设置大小值；

- 不是经常执行的方法，默认情况下，方法大小小于 35 字节才会进行内联，我们也可以通过 -XX:MaxInlineSize=N 来重置大小值。

#### 逃逸分析

##### 逃逸分析(（Escape Analysis）)是指通过数据流分析，判断一个对象会不会被传递到当前编译的方法之外。比如说你调用了一个方法，将一个新建的对象作为参数传递出去，如果这个方法没有被内联，则说明该新建对象会逃逸。

##### 逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”

````
在 Java 虚拟机的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。

即时编译器判断对象是否逃逸的依据，一是对象是否被存入堆中（静态字段或者堆中对象的实例字段），二是对象是否被传入未知代码中
````

##### 基于逃逸分析的优化

- 锁消除

````
1. 如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没有意义。
2. 这是因为其他线程并不能获得该锁对象，因此也不可能对其进行加锁。在这种情况下，即时编译器可以消除对该不逃逸锁对象的加锁、解锁操作

````

synchronized (new Object()) {}会被完全优化掉。这正是因为基于逃逸分析的锁消除。由于其他线程不能获得该锁对象，因此也无法基于该锁对象构造两个线程之间的 happens-before
规则。synchronized (escapedObject) {}则不然。由于其他线程可能会对逃逸了的对象escapedObject进行加锁操作，从而构造了两个线程之间的 happens-before
关系。因此即时编译器至少需要为这段代码生成一条刷新缓存的内存屏障指令

- 栈上分配: 逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。

````
如果逃逸分析能够证明某些新建的对象不逃逸，那么 Java 虚拟机完全可以将其分配至栈上，并且在 new 语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象
````

不过，由于实现起来需要更改大量假设了“对象只能堆分配”的代码，因此 HotSpot 虚拟机并没有采用栈上分配

- 标量替换: 逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。

````
标量替换这项优化技术，可以看成将原本对对象的字段的访问，替换为一个个局部变量的访问。

```` 


---

### java语言是解释型还是编译型

- 一、你可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。
- 二、你可以说它是解释型的。因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。
- 三、但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的。

像C、C++==- 他们经过一次编译之后直接可以编译成操作系统了解的类型，可以直接执行的 所以他们是编译型的语言。没有经过第二次的处理 而Java不一样他首先由编译器编译成.class类型的文件，这个是java自己类型的文件 然后在通过虚拟机(JVM)从.class文件中读一行解释执行一行，所以他是解释型的语言，而由于java对于多种不同的操作系统有不同的JVM所以 Java实现了真正意义上的跨平台！

#### 编译型语言和解释型语言的定义:

- 定义： 编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。 解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！

- 区别： 编译型语言，执行速度快、效率高；依靠编译器、跨平台性差些。 解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。

- java是解释型的语言，因为虽然java也需要编译，编译成.class文件，但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释，才能在各个平台执行，这同时也是java跨平台的原因。所以可是说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中
