### JVM

#### java虚拟机-> 路径: Path,ClassPath,JAVA_HOME

#### JAVA_HOME

- 方便引用，配置path时，就是通过引用JAVA_HOME路径来实现的，这样避免了写很长一串的路径（比如在我的电脑中，path原路径是”C:\Program
  Files\Java\jdk1.8.0_131\bin”，通过指定JAVA_HOME，现在设定的path路径变成了”%JAVA_HOME%\bin”，更加简洁）

- 更加安全，当JDK改变时，仅需要改变JAVA_HOME的路径即可，path和CLASSPATH由于引用了JAVA_HOME，其所对应的路径也会更改。如果不引用JAVA_HOME，则JDK路径改变时，需要手动去设定PATH和CLASSPATH的路径，一旦路径错误，则程序会崩溃。

- 第三方软件（如tomcat，eclipse）都是引用约定好的JAVA_HOME变量，如果不指定JAVA_HOME，则将无法使用第三方软件。

#### path

- 配置Path是为了在任意目录下都能使用java、javac命令。

#### classPath

- 配置CLASSPATH是为了引入一些已经写好的类。

- 我们一般这样设置：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;

- 前面的“.”不可少，它代表了我们为自己的java类建立的工作路径，其它的是jdk自带的标准类库路径。

------
### java指令编译运行以及反汇编

- 反编译：将 .class 文件逆向成 java源代码

- 反汇编：根据编译后的结果，倒推源码编译的过程，这里就可以看出代码逻辑真实编译、执行过程的每一步，对于性能优化、问题追溯等具有十分强大的帮助

- javac;//编译

```
cd /Users/nivellefu/IdeaProjects/javadaybyday/java-base/src/main/java/com/nivelle/base/pojo/javaclass;javac -d . /Users/nivellefu/IdeaProjects/javadaybyday/java-base/src/main/java/com/nivelle/base/pojo/javaclass/JvmExceptionDemo.java
```

- java;//运行

```
java class文件指定的page路径+类名

```

- javap -v -p //根据classs字节码文件，反解析出当前类对应的code区（汇编指令），本地变量表，异常表和代码偏移量映射表，常量池等信息。

```
javap com.nivelle.base.pojo.javaclass/JvmExceptionDemo


Compiled from "JvmExceptionDemo.java"
public class com.nivelle.base.pojo.javaclass.JvmExceptionDemo {
  public com.nivelle.base.pojo.javaclass.JvmExceptionDemo();
  public void test();
  public static void main(java.lang.String[]);
}

 
```
----------------------

### 编译加载

![类加载编译过程.jpg](https://i.loli.net/2020/04/05/h3jRw2eDUY1dkB5.jpg)

- 编译后的字节码文件主要包括常量池和方法表集合这两部分

1. 常量池主要记录的是类文件中出现的字面量以及符号引用。字面常量包括字符串常量（例如 String str=“abc”，其中"abc"就是常量），声明为 final 的属性以及一些基本类型（例如，范围在 -127-128
   之间的整型）的属性。 符号引用包括类和接口的全限定名、类引用、方法引用以及成员变量引用（例如 String str=“abc”，其中 str 就是成员变量引用）等。

2. 方法表集合中主要包含一些方法的字节码、方法访问权限（public、protect、private 等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM 执行指令以及属性集合等。

### 类的加载

- 除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载

- 拓展类加载器，引用类加载器、自定义类加载器是java.lang.ClassLoader的子类实例，自定义类加载器直接继承java.lang.classLoader

#### 类加载,是指查找字节流,并且据此创建类的过程；查找并加载类的二进制数据到java虚拟机中

- Bootstrap 启动类加载器:JDK\jre\lib 目录下 jar包中的类或者由虚拟机参数 **-Xbootclasspath** 指定的类, 比如 rt.jar、charsets.jar;同时所有的java.开头的类

启动类加载器是无法被java程序直接引用的。启动类加载器加载java运行过程中的核心类库：

````
1. JRE\lib\rt.jar
2. sunrsasign.jar
3. charsets.jar
4. jce.jar
5. jsse.jar
6. plugin.jar
7. 存放在JRE\classess里面的类，也就是JDK提供的类比如常见的: Object、String、List
````

- Extension扩展类加载器:JDK\jre\lib\ext 目录下 jar 包中的类或者由系统变量 **java.ext.dirs**指定的类,比如 dnsns.jar、zipfs.jar;以javax.开头的类，开发者可以直接使用拓展类加载器

````
Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。
````

- Application应用类加载器:它负责加载应用程序路径下的类 -cp也就是-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径

##### JVM 会先加载 class 文件，而在 class 文件中除了有类的版本、字段、方法和接口等描述信息外,还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种字面量和符号引用

**(类加载进内存后，JVM就会将class文件常量池中的内容存放到运行时常量池中也就是方法区中)**

1. 字面量:字符串,基本类型的常量

2. 符号引用: 类和方法的全限定名


#### 双亲委派机制

- 避免类的重复加载:当父加载器已经加载了该类的时候,就没必要子ClassLoader再加载一次,保证被加载类的唯一性

- 沙箱子安全机制: 自己写的java.lang.String.class 类不会被加载，这样防止核心API库被随意串改

#### 类加载器的名字空间作用
````
在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。
````

-----------------
### 类的链接

**是指将创建成的类合并至 Java 虚拟机中,使之能够执行的过程**

- 第一步验证:文件合法性检查

- 第二步准备:

(1). **被加载类的静态字段分配内存**

(2). 对于 **final static** 修饰的变量,直接赋值为用户的定义值。

(3). 构造其他跟类层次相关的数据结构，比如用来实现虚方法的动态绑定的方法表

 ````
 例如:private final static int value=123,会在准备阶段分配内存,并初始化值为 123,
 
 而如果是 private static int value=123，这个准备阶段 value 的值仍然为 0。 
 ````

- 第三步解析：

````
Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

````

(1).符号引用->实际引用; 

````
在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

符号引用:编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用来指代所要调用的方法;
````

(2).形成对常量池字符串的索引值;

(3).如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化）

### 类的初始化

- **为类的静态变量赋予正确的初始值**，在准备阶段仅仅是分配了内存，提供的是默认值

##### 为标记为常量值的字段赋值,以及执行 <clinit> 方法的过程。类的初始化仅会被执行一次,这个特性被用来实现单例的延迟初始化。

- 如果要初始化一个静态字段,我们可以在声明时直接赋值,也可以在静态代码块中对其赋值

- 如果直接赋值的静态字段被 final 所修饰,并且它的类型是基本类型或字符串时,那么该字段便会被 Java 编译器标记成常量值(ConstantValue)其初始化直接由 Java
  虚拟机完成。除此之外的直接赋值操作,以及所有静态代码块中的代码,则会被 Java 编译器置于同一方法中,并把它命名为 <clinit>。

- Java 虚拟机会通过加锁来确保类的 <clinit> 方法仅被执行一次

##### java类的初始化触发

(1). 当虚拟机启动时,初始化用户指定的主类；

(2). 当遇到用以**新建目标类**实例的 new 指令时,初始化 new 指令的目标类；

(3). 当遇到调用**静态方法**的指令时,初始化该静态方法所在的类;

(4). 当遇到访问**静态字段**的指令时,初始化该静态字段所在的类;

(5). 子类的初始化会触发父类的初始化;

(6). 如果一个接口定义了 default 方法,那么直接实现或者间接实现该接口的类的初始化,会触发该接口的初始化;

(7). 使用反射 API 对某个类进行反射调用时,初始化这个类；

(8). 当初次调用 MethodHandle 实例时,初始化该 MethodHandle 指向的方法所在的类。

### 解释器执行与即时编译

在 HotSpot 里面,将字节码翻译为机器码有两种方式，第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译(just-in-time compilation,JIT),即将一个方法中包含的所有字节码编译成机器码后再执行


#### 解释器模式(interpreter)

- 一条一条地读取,解释并且执行字节码指令。因为它一条一条地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢，没有JIT的配合下效率不高

- 指定“-Xint”，就是告诉 JVM 只进行解释执行，不对代码进行编译，这种模式抛弃了 JIT 可能带来的性能优势

- “-Xcomp”参数，这是告诉 JVM 关闭解释器，不要进行解释执行，或者叫作最大优化级别

#### 动态编译模式(Just-In-Time):

- 即时编译器把整段字节码不加筛选的编译成机器码不论其执行频率是否有编译价值，在程序响应时间的限制下，没有达到最大的优化。

- C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。

- C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。

- Java 8 默认开启了分层编译。

  (1). 第 0 层：程序解释执行,默认开启性能监控功能（Profiling）,如果不开启,可触发第二层编译;

  (2). 第 1 层: 可称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启 Profiling；

  (3). 第 2 层： 也称为 C1 编译,开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译；

  (4). 第 3 层：也称为 C1 编译,执行所有带 Profiling 的 C1 编译；

  (5). 第 4 层：可称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。、


#### 热点探测

##### 方法调用计数器

- XX:TieredStopAtLevel = 1 仅仅使用C1编译 在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的和，超过由参数 -XX:CompileThreshold 指定的阈值时（使用 C1 时，该值为
  1500；使用 C2 时，该值为 10000），便会触发即时编译

##### 启用分层编译时，Java 虚拟机将不再采用由参数 -XX:CompileThreshold 指定的阈值（该参数失效），阈值的大小是动态调整的，Java 虚拟机会将阈值与某个系数 s 相乘。该系数与当前待编译的方法数目成正相关，与编译线程的数目成负相关

- XX:-TieredCompilation 关闭分层编译

- Xint: 强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作

- Xcomp:强制虚拟机运行于只有 JIT 的编译模式下

##### 回变计数器

用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge);

- 该值用于计算是否触发 C1 编译的阈值，在不开启分层编译的情况下，C1 默认为 13995，C2 默认为 10700，

- 通过 -XX: OnStackReplacePercentage=N 来设置；

而在分层编译的情况下，-XX: OnStackReplacePercentage 指定的阈值同样会失效，此时将根据当前待编译的方法数以及编译线程数来动态调整。建立回边计数器的主要目的是为了触发 OSR（On
StackReplacement）编译，即栈上编译，将编译后的机器语言缓存。

### jvm 方法调用

- 重写: 多态最重要的一种体现方，它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

- 重载: 名字相同,参数类型不同的方法;重载也可以作用于这个类所继承而来的方法；

```
重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；

2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；

3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

```

- Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说， 由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

```

在编译完成之后，我们可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。

当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在Java编译器的用户类路径上时，当前版本的Java编译器会直接选取第一个方法名以及参数类型匹配的方法。

并且，它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。

```

- Java 虚拟机的动态绑定是通过**方法表**这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。

- Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。

### Java方法反射调用性能慢的原因:

1. 由于Method.invoke是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组

2. 由于Object数组不能存储基本类型,Java 编译器会对传入的基本类型参数进行自动装箱

**以上两个操作除了带来性能开销外,还可能占用堆内存,使得 GC 更加频繁。**

3. 方法内联:方法内联指的是编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法调用这么个过程

内联函数就是指函数在被调用的地方直接展开，编译器在调用时不用像一般函数那样，参数压栈，返回时参数出栈以及资源释放等，这样提高了程序执行速度。Java不支持直接声明为内联函数的，如果想让他内联，则是由编译器说了算，你只能够向编译器提出请求。

### jvm虚拟机处理异常

- 在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode
  index，bci），用以定位字节码。

- 当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java
  虚拟机会将控制流转移至该条目 target 指针指向的字节码。如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java
  虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。

- from 指针和 to 指针标示了该异常处理器所监控的范围

- target 指针则指向异常处理器的起始位置

- Java 字节码中，每个方法对应一个异常表。当程序触发异常时，Java 虚拟机将查找异常表，并依此决定需要将控制流转移至哪个异常处理器之中。Java 代码中的 catch 代码块和 finally 代码块都会生成异常表条目。

### 编译优化

#### 方法内联

方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。

- 经常执行的方法，默认情况下，方法体大小小于 325 字节的都会进行内联，我们可以通过 -XX:MaxFreqInlineSize=N 来设置大小值；

- 不是经常执行的方法，默认情况下，方法大小小于 35 字节才会进行内联，我们也可以通过 -XX:MaxInlineSize=N 来重置大小值。

#### 逃逸分析

逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。

- 栈上分配: 逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。

- 标量替换: 逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。
