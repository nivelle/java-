### jvm方法调用

#### 重载与重写

- 我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这些方法之间的关系，我们称之为重载

- 这个限制可以通过字节码工具绕开

````
1. 在编译完成之后，我们可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。

2. 当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在Java编译器的用户类路径上时，它是怎么确定需要调用哪个方法的呢？

3. 当前版本的Java编译器会直接选取第一个方法名以及参数类型匹配的方法。并且，它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。

````

#### 重载方法选择

- 在不考虑对基本类型自动装拆箱，以及可变长参数的情况下选取重载方法

- 如果在第1个阶段中没有找到适配的方法，那么允许自动拆箱，但不允许可变长参数的情况下选取重载方法

- 如果在第2个阶段没有找到适配的方法，那么允许自动拆箱以及可变长参数的情况下选取重载方法

- 如果java编译器在同一个阶段中找到了多个适配方法，那么它会在其中选择一个最为贴切的，而觉定贴切程度的一个关键就是形式参数类型的继承关系

````

void invoke(Object obj, Object... args) { ... }
void invoke(String s, Object obj, Object... args) { ... }

比如传入null时，它既可以匹配第一个方法中声明为Object的形式参数，也可以匹配第二个方法声明为String的形式参数。
由于String是Object的子类，因此java编译器会认为第二个方法更为贴切
````

- 除了同一个类中的方法，重载也可以作用于这个类继承而来的方法。

````
如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。
````

#### 方法重写

- 如果子类定义了与父类中非私有方法同名的方法，而且这俩方法参数类型相同，且为非静态非私有

- 如果两个方法都是静态的，那么子类中的方法隐藏了父类中的方法

### jvm的静态绑定和动态绑定

- Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）

- 方法描述符:它是由方法的参数类型以及返回类型所构成。
````  
在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。
````

- java虚拟机中关于方法重写的判定基于方法描述符。如果子类定义与父类中非私有、非静态方法同名的方法，那么只有当两个方法的参数类型以及返回类型一致，java虚拟机才会判定为重写

- 对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法来实现 Java 中的重写语义。

````
指仅返回值不一样的方法，Java语言认为是重写，JVM认为不是重写。

为了让JVM能够认为是重写，需要定义一个参数和返回值一样的方法，让它调用那个返回值不一样的方法，但是Java语言不允许在同一个类中出现仅返回值不一样的两个方法，只好借助于Java编译器合成一个方法，也就是桥接方法。

由于返回值是被桥接的目标方法的返回值的子类型，可以直接返回。

````

- 对重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念。因此，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）

````
这个说法在 Java 虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。

````


### java字节码中调用相关的指令

1. invokestatic：用于调用静态方法。
   
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
   
3. invokevirtual：用于调用非私有实例方法。
   
4. invokeinterface：用于调用接口方法。
   
5. invokedynamic：用于调用动态方法。

- 对于 invokestatic 以及 invokespecial 而言，Java 虚拟机能够直接识别具体的目标方法。

- 而对于 invokevirtual 以及 invokeinterface 而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法

````
唯一的例外在于，如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final[3][4]，那么它可以不通过动态类型，直接确定目标方法
````

#### 调用指令的符号引用

- 对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找:

1. 在 C 中查找符合名字及描述符的方法

2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。

3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个

- 对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找：

1. 在 I 中查找符合名字及描述符的方法

2. 如果没有找到，在 Object 类中的公有实例方法中搜索

3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致

### 虚方法调用

- Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的虚方法调用。

- 如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法

#### 方法表

- 类加载的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。

- 方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。

- 方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

````
方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）
````

- 在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。

### 即时编译下的优化

#### 内联缓存

````
内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。
在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。
如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定
````

------


- 加载阶段构造虚方法的数组结构的方法表，解析阶段把编译时的虚方法的符号引用解析为虚方法表中对应的下标，动态调用时从栈上获取实际类型，查找对应类型虚方法表的下标，获取对应的方法，正因为此，所以要求子类从父类继承方法、重写方法的下标相同。

- 内联缓存并不是方法内联，只是缓存了调用者的实际类型和对应的目标方法，当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法，节约了查找方法表的时间，其实也就节约了一次数组结构的搜索，这种节约的意义并不是非常的大，所以多态内联时就直接退化为了方法表查找的方式。

