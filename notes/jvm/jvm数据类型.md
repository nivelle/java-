### JVM数据类型

- 基本类型

- 引用类型: 类、接口、数组类和泛型参数,泛型参数会在编译过程中被擦除; 数组类是由 Java 虚拟机直接生成

- boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1,而“false”被映射为整数 0;

### java基本类型的大小

1. 在 Java 虚拟机规范中,局部变量区等价于一个数组,并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外,其他基本类型以及引用类型的值均占用一个数组单元。

2. boolean、byte、char、short 这四种类型，在栈上占用的空间和 int、引用类型也是一样的。

3. 作为局部变量,在 32 位的 HotSpot 中,基本类型在栈上将占用 4 个字节;而在 64 位的 HotSpot 中,他们将占 8 个字节。

4. 这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为1字节、2字节、2字节，也就是说,跟这些类型的值域相吻合


### jvm java对象

- 对象头:

1. 标记字段: java虚拟机有关该对象运行数据：如哈希码、GC信息、锁信息

 ```
 在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。以 Integer 类为例，它仅有一个 int 类型的私有字段，占 4 个字节。因此，每一个 Integer 对象的额外内存开销至少是 400%。这也是为什么 Java 要引入基本类型的原因之一。
 ```

2. 类型指针 : 指向该对象的类

- 压缩指针: 为了减少类型指针的内存占用，将64位指针压缩至32位，进而节约内存。之前64位寻址，寻的是字节。现在32位寻址，寻的是变量。再加上内存对齐(补齐为8的倍数)，可以每次寻变量都以一定的规则寻找，并且一定可以找得到。

- 内存对齐:

    1. 默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充（padding）

    2. 内存对齐的另一个好处是,使得CPU缓存行可以更好的实施。保证每个变量都只出现在一条缓存行中，不会出现跨行缓存。提高程序的执行效率。

- 字段重排序: 其实就是更好的执行内存对齐标准,会调整字段在内存中的分布,达到方便寻址和节省空间的目的。

- 虚共享:
  当两个线程分别访问一个对象中的不同volatile字段，理论上是不涉及变量共享和同步要求的。但是如果两个volatile字段处于同一个CPU缓存行中，对其中一个volatile字段的写操作，会导致整个缓存行的写回和读取操作，进而影响到了另一个volatile变量，也就是实际上的共享问题

    - @Contented注解:该注解就是用来解决虚共享问题的，被该注解标识的变量，会独占一个CPU缓存行。但也因此浪费了大量的内存空间。
