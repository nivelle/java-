### java内存模型

#### 计算机内存概要

- cpu在执行指令时将主存中的数据复制到高速缓存中,将结果运算完毕后再将运算结果刷新到主存中。

[![rUdqM9.png](https://s3.ax1x.com/2020/12/20/rUdqM9.png)](https://imgchr.com/i/rUdqM9)

#### 缓存一致性实现方式

- 通过总线加Lock锁的方法
- 通过缓存一致性协议(最出名：Intel的MESI协议)【M:修改；E:独占；S:共享 I:失效 】

````
MESI协议保证了每个缓存中使用的共享变量的副本是一致的，它的核心思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号
通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么就会从内存重新读取。

多处理器下,为了保证各个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存对应的内存地址被修改，就会将当前处理器缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，
会重新从系统内存中把数据读到处理器缓存里。
````

#### 并发变编程三个概念

- 原子性 

- 可见性(针对操作系统的多级缓存)

- 有序性(针对JVM的指令重排序)

### volatile实现原理

- java内存模型看来，各个线程会将从共享变量从主存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行处理。

- 针对volatile修饰的变量给java虚拟机特殊约定,线程对volatile变量的修改会立刻被其他线程所感知,即不会出现数据脏读现象,从而保证数据的"可见性"

##### 在生成汇编指令代码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令：

- Lock前缀的指令会引起处理器缓存写回主存,对缓存行加锁
- 一个处理器的缓存回写到内存会导致其他处理器的缓存失效
- 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可获取当前最新值


#### volatile与happens-before(先行发生)原则

- 在计算机科学中，先行产生原则是两个事件的结果之间的关系，如果一个事件产生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的。

- 对一个volatile变量的写操作先行产生与后面对这个变量的读操作

#### volatile内存语义及实现（内存屏障）

- JVM 在编译java代码时，或者CPU在执行JVM字节码时，对现有的指令顺序进行重排序

- 指令重排序的目的时为了在不改变运行结果的前提下，优化程序执行效率(指单线程下不影响程序执行结果)，指令重排序影响多线程情况下的执行结果；

#### JMM: 8大数据原子操作

1. lock(锁定)：用于主内存的变量，把一个变量标记为一条线程独占状态
2. unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3. read(读取)：把一个变量从主内存传输到线程的工作内存，以便随后的load动作使用
4. load(载入)：它把read操作从主内存得到的变量值放入工作内存的变量副本中
5. use(使用)：把工作内存中的一个变量值传递给执行引擎
6. assign(赋值)：它把一个从执行引擎接收到的值赋给工作内存的变量
7. store(存储)：它把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
8. write(写入)：把store操作从工作内存中的一百年变量的值传送到主内存的变量之中

         